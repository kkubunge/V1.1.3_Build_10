#include <stdio.h>
#include <process.h>
#include <time.h>
#include <windows.h>
#include <wingdi.h>
#include <winbase.h>
#include <windowsx.h>
//----------------------------------------------------------------------------------
// failure  78 
// present 108
// process 118
//----------------------------------------------------------------------------------
//----------------------------------------------------------------------------------
double memsin[] = {
	0.000000 ,	0.001745 ,	0.003491 ,	0.005236 ,	0.006981 ,	0.008727 ,	0.010472 ,	0.012217 ,	0.013962 ,	0.015707 ,
	0.017452 ,	0.019197 ,	0.020942 ,	0.022687 ,	0.024432 ,	0.026177 ,	0.027922 ,	0.029666 ,	0.031411 ,	0.033155 ,
	0.034899 ,	0.036644 ,	0.038388 ,	0.040132 ,	0.041876 ,	0.043619 ,	0.045363 ,	0.047106 ,	0.048850 ,	0.050593 ,
	0.052336 ,	0.054079 ,	0.055822 ,	0.057564 ,	0.059306 ,	0.061049 ,	0.062791 ,	0.064532 ,	0.066274 ,	0.068015 ,
	0.069756 ,	0.071497 ,	0.073238 ,	0.074979 ,	0.076719 ,	0.078459 ,	0.080199 ,	0.081939 ,	0.083678 ,	0.085417 ,
	0.087156 ,	0.088894 ,	0.090633 ,	0.092371 ,	0.094108 ,	0.095846 ,	0.097583 ,	0.099320 ,	0.101056 ,	0.102793 ,
	0.104528 ,	0.106264 ,	0.107999 ,	0.109734 ,	0.111469 ,	0.113203 ,	0.114937 ,	0.116671 ,	0.118404 ,	0.120137 ,
	0.121869 ,	0.123601 ,	0.125333 ,	0.127065 ,	0.128796 ,	0.130526 ,	0.132256 ,	0.133986 ,	0.135716 ,	0.137445 ,
	0.139173 ,	0.140901 ,	0.142629 ,	0.144356 ,	0.146083 ,	0.147809 ,	0.149535 ,	0.151261 ,	0.152986 ,	0.154710 ,
	0.156434 ,	0.158158 ,	0.159881 ,	0.161604 ,	0.163326 ,	0.165048 ,	0.166769 ,	0.168489 ,	0.170209 ,	0.171929 ,
	0.173648 ,	0.175367 ,	0.177085 ,	0.178802 ,	0.180519 ,	0.182236 ,	0.183951 ,	0.185667 ,	0.187381 ,	0.189095 ,
	0.190809 ,	0.192522 ,	0.194234 ,	0.195946 ,	0.197657 ,	0.199368 ,	0.201078 ,	0.202787 ,	0.204496 ,	0.206204 ,
	0.207912 ,	0.209619 ,	0.211325 ,	0.213030 ,	0.214735 ,	0.216440 ,	0.218143 ,	0.219846 ,	0.221548 ,	0.223250 ,
	0.224951 ,	0.226651 ,	0.228351 ,	0.230050 ,	0.231748 ,	0.233445 ,	0.235142 ,	0.236838 ,	0.238533 ,	0.240228 ,
	0.241922 ,	0.243615 ,	0.245307 ,	0.246999 ,	0.248690 ,	0.250380 ,	0.252069 ,	0.253758 ,	0.255446 ,	0.257133 ,
	0.258819 ,	0.260505 ,	0.262189 ,	0.263873 ,	0.265556 ,	0.267238 ,	0.268920 ,	0.270600 ,	0.272280 ,	0.273959 ,
	0.275637 ,	0.277315 ,	0.278991 ,	0.280667 ,	0.282341 ,	0.284015 ,	0.285688 ,	0.287361 ,	0.289032 ,	0.290702 ,
	0.292372 ,	0.294040 ,	0.295708 ,	0.297375 ,	0.299041 ,	0.300706 ,	0.302370 ,	0.304033 ,	0.305695 ,	0.307357 ,
	0.309017 ,	0.310676 ,	0.312335 ,	0.313992 ,	0.315649 ,	0.317305 ,	0.318959 ,	0.320613 ,	0.322266 ,	0.323917 ,
	0.325568 ,	0.327218 ,	0.328867 ,	0.330514 ,	0.332161 ,	0.333807 ,	0.335452 ,	0.337095 ,	0.338738 ,	0.340380 ,
	0.342020 ,	0.343660 ,	0.345298 ,	0.346936 ,	0.348572 ,	0.350207 ,	0.351842 ,	0.353475 ,	0.355107 ,	0.356738 ,
	0.358368 ,	0.359997 ,	0.361625 ,	0.363251 ,	0.364877 ,	0.366501 ,	0.368125 ,	0.369747 ,	0.371368 ,	0.372988 ,
	0.374607 ,	0.376224 ,	0.377841 ,	0.379456 ,	0.381070 ,	0.382683 ,	0.384295 ,	0.385906 ,	0.387516 ,	0.389124 ,
	0.390731 ,	0.392337 ,	0.393942 ,	0.395546 ,	0.397148 ,	0.398749 ,	0.400349 ,	0.401948 ,	0.403545 ,	0.405142 ,
	0.406737 ,	0.408330 ,	0.409923 ,	0.411514 ,	0.413104 ,	0.414693 ,	0.416281 ,	0.417867 ,	0.419452 ,	0.421036 ,
	0.422618 ,	0.424199 ,	0.425779 ,	0.427358 ,	0.428935 ,	0.430511 ,	0.432086 ,	0.433659 ,	0.435231 ,	0.436802 ,
	0.438371 ,	0.439939 ,	0.441506 ,	0.443071 ,	0.444635 ,	0.446198 ,	0.447759 ,	0.449319 ,	0.450878 ,	0.452435 ,
	0.453990 ,	0.455545 ,	0.457098 ,	0.458650 ,	0.460200 ,	0.461749 ,	0.463296 ,	0.464842 ,	0.466387 ,	0.467930 ,
	0.469472 ,	0.471012 ,	0.472551 ,	0.474088 ,	0.475624 ,	0.477159 ,	0.478692 ,	0.480223 ,	0.481754 ,	0.483282 ,
	0.484810 ,	0.486335 ,	0.487860 ,	0.489382 ,	0.490904 ,	0.492424 ,	0.493942 ,	0.495459 ,	0.496974 ,	0.498488 ,
	0.500000 ,	0.501511 ,	0.503020 ,	0.504528 ,	0.506034 ,	0.507538 ,	0.509041 ,	0.510543 ,	0.512043 ,	0.513541 ,
	0.515038 ,	0.516533 ,	0.518027 ,	0.519519 ,	0.521010 ,	0.522499 ,	0.523986 ,	0.525472 ,	0.526956 ,	0.528438 ,
	0.529919 ,	0.531399 ,	0.532876 ,	0.534352 ,	0.535827 ,	0.537300 ,	0.538771 ,	0.540240 ,	0.541708 ,	0.543174 ,
	0.544639 ,	0.546102 ,	0.547563 ,	0.549023 ,	0.550481 ,	0.551937 ,	0.553392 ,	0.554844 ,	0.556296 ,	0.557745 ,
	0.559193 ,	0.560639 ,	0.562083 ,	0.563526 ,	0.564967 ,	0.566406 ,	0.567844 ,	0.569280 ,	0.570714 ,	0.572146 ,
	0.573576 ,	0.575005 ,	0.576432 ,	0.577858 ,	0.579281 ,	0.580703 ,	0.582123 ,	0.583541 ,	0.584958 ,	0.586372 ,
	0.587785 ,	0.589196 ,	0.590606 ,	0.592013 ,	0.593419 ,	0.594823 ,	0.596225 ,	0.597625 ,	0.599024 ,	0.600420 ,
	0.601815 ,	0.603208 ,	0.604599 ,	0.605988 ,	0.607376 ,	0.608761 ,	0.610145 ,	0.611527 ,	0.612907 ,	0.614285 ,
	0.615661 ,	0.617036 ,	0.618408 ,	0.619779 ,	0.621148 ,	0.622515 ,	0.623880 ,	0.625243 ,	0.626604 ,	0.627963 ,
	0.629320 ,	0.630676 ,	0.632029 ,	0.633381 ,	0.634731 ,	0.636078 ,	0.637424 ,	0.638768 ,	0.640110 ,	0.641450 ,
	0.642788 ,	0.644124 ,	0.645458 ,	0.646790 ,	0.648120 ,	0.649448 ,	0.650774 ,	0.652098 ,	0.653421 ,	0.654741 ,
	0.656059 ,	0.657375 ,	0.658689 ,	0.660002 ,	0.661312 ,	0.662620 ,	0.663926 ,	0.665230 ,	0.666532 ,	0.667833 ,
	0.669131 ,	0.670427 ,	0.671721 ,	0.673013 ,	0.674302 ,	0.675590 ,	0.676876 ,	0.678160 ,	0.679441 ,	0.680721 ,
	0.681998 ,	0.683274 ,	0.684547 ,	0.685818 ,	0.687088 ,	0.688355 ,	0.689620 ,	0.690882 ,	0.692143 ,	0.693402 ,
	0.694658 ,	0.695913 ,	0.697165 ,	0.698415 ,	0.699663 ,	0.700909 ,	0.702153 ,	0.703395 ,	0.704634 ,	0.705872 ,
	0.707107 ,	0.708340 ,	0.709571 ,	0.710799 ,	0.712026 ,	0.713250 ,	0.714473 ,	0.715693 ,	0.716911 ,	0.718126 ,
	0.719340 ,	0.720551 ,	0.721760 ,	0.722967 ,	0.724172 ,	0.725374 ,	0.726575 ,	0.727773 ,	0.728969 ,	0.730162 ,
	0.731354 ,	0.732543 ,	0.733730 ,	0.734915 ,	0.736097 ,	0.737277 ,	0.738455 ,	0.739631 ,	0.740805 ,	0.741976 ,
	0.743145 ,	0.744312 ,	0.745476 ,	0.746638 ,	0.747798 ,	0.748956 ,	0.750111 ,	0.751264 ,	0.752415 ,	0.753563 ,
	0.754710 ,	0.755853 ,	0.756995 ,	0.758134 ,	0.759271 ,	0.760406 ,	0.761538 ,	0.762668 ,	0.763796 ,	0.764921 ,
	0.766044 ,	0.767165 ,	0.768284 ,	0.769400 ,	0.770513 ,	0.771625 ,	0.772734 ,	0.773840 ,	0.774944 ,	0.776046 ,
	0.777146 ,	0.778243 ,	0.779338 ,	0.780430 ,	0.781520 ,	0.782608 ,	0.783693 ,	0.784776 ,	0.785857 ,	0.786935 ,
	0.788011 ,	0.789084 ,	0.790155 ,	0.791224 ,	0.792290 ,	0.793353 ,	0.794415 ,	0.795473 ,	0.796530 ,	0.797584 ,
	0.798636 ,	0.799685 ,	0.800731 ,	0.801776 ,	0.802817 ,	0.803857 ,	0.804894 ,	0.805928 ,	0.806960 ,	0.807990 ,
	0.809017 ,	0.810042 ,	0.811064 ,	0.812084 ,	0.813101 ,	0.814116 ,	0.815128 ,	0.816138 ,	0.817145 ,	0.818150 ,
	0.819152 ,	0.820152 ,	0.821149 ,	0.822144 ,	0.823136 ,	0.824126 ,	0.825113 ,	0.826098 ,	0.827081 ,	0.828060 ,
	0.829038 ,	0.830012 ,	0.830984 ,	0.831954 ,	0.832921 ,	0.833886 ,	0.834848 ,	0.835807 ,	0.836764 ,	0.837719 ,
	0.838671 ,	0.839620 ,	0.840567 ,	0.841511 ,	0.842452 ,	0.843391 ,	0.844328 ,	0.845262 ,	0.846193 ,	0.847122 ,
	0.848048 ,	0.848972 ,	0.849893 ,	0.850811 ,	0.851727 ,	0.852640 ,	0.853551 ,	0.854459 ,	0.855364 ,	0.856267 ,
	0.857167 ,	0.858065 ,	0.858960 ,	0.859852 ,	0.860742 ,	0.861629 ,	0.862514 ,	0.863396 ,	0.864275 ,	0.865151 ,
	0.866025 ,	0.866897 ,	0.867765 ,	0.868632 ,	0.869495 ,	0.870356 ,	0.871214 ,	0.872069 ,	0.872922 ,	0.873772 ,
	0.874620 ,	0.875465 ,	0.876307 ,	0.877146 ,	0.877983 ,	0.878817 ,	0.879649 ,	0.880477 ,	0.881303 ,	0.882127 ,
	0.882948 ,	0.883766 ,	0.884581 ,	0.885394 ,	0.886204 ,	0.887011 ,	0.887815 ,	0.888617 ,	0.889416 ,	0.890213 ,
	0.891007 ,	0.891798 ,	0.892586 ,	0.893371 ,	0.894154 ,	0.894934 ,	0.895712 ,	0.896486 ,	0.897258 ,	0.898028 ,
	0.898794 ,	0.899558 ,	0.900319 ,	0.901077 ,	0.901833 ,	0.902585 ,	0.903335 ,	0.904083 ,	0.904827 ,	0.905569 ,
	0.906308 ,	0.907044 ,	0.907777 ,	0.908508 ,	0.909236 ,	0.909961 ,	0.910684 ,	0.911403 ,	0.912120 ,	0.912834 ,
	0.913545 ,	0.914254 ,	0.914960 ,	0.915663 ,	0.916363 ,	0.917060 ,	0.917755 ,	0.918446 ,	0.919135 ,	0.919821 ,
	0.920505 ,	0.921185 ,	0.921863 ,	0.922538 ,	0.923210 ,	0.923880 ,	0.924546 ,	0.925210 ,	0.925871 ,	0.926529 ,
	0.927184 ,	0.927836 ,	0.928486 ,	0.929133 ,	0.929776 ,	0.930418 ,	0.931056 ,	0.931691 ,	0.932324 ,	0.932954 ,
	0.933580 ,	0.934204 ,	0.934826 ,	0.935444 ,	0.936060 ,	0.936672 ,	0.937282 ,	0.937889 ,	0.938493 ,	0.939094 ,
	0.939693 ,	0.940288 ,	0.940881 ,	0.941471 ,	0.942057 ,	0.942641 ,	0.943223 ,	0.943801 ,	0.944376 ,	0.944949 ,
	0.945519 ,	0.946085 ,	0.946649 ,	0.947210 ,	0.947768 ,	0.948324 ,	0.948876 ,	0.949425 ,	0.949972 ,	0.950516 ,
	0.951057 ,	0.951594 ,	0.952129 ,	0.952661 ,	0.953191 ,	0.953717 ,	0.954240 ,	0.954761 ,	0.955278 ,	0.955793 ,
	0.956305 ,	0.956814 ,	0.957319 ,	0.957822 ,	0.958323 ,	0.958820 ,	0.959314 ,	0.959805 ,	0.960294 ,	0.960779 ,
	0.961262 ,	0.961741 ,	0.962218 ,	0.962692 ,	0.963163 ,	0.963630 ,	0.964095 ,	0.964557 ,	0.965016 ,	0.965473 ,
	0.965926 ,	0.966376 ,	0.966823 ,	0.967268 ,	0.967709 ,	0.968148 ,	0.968583 ,	0.969016 ,	0.969445 ,	0.969872 ,
	0.970296 ,	0.970716 ,	0.971134 ,	0.971549 ,	0.971961 ,	0.972370 ,	0.972776 ,	0.973179 ,	0.973579 ,	0.973976 ,
	0.974370 ,	0.974761 ,	0.975149 ,	0.975535 ,	0.975917 ,	0.976296 ,	0.976672 ,	0.977046 ,	0.977416 ,	0.977783 ,
	0.978148 ,	0.978509 ,	0.978867 ,	0.979223 ,	0.979575 ,	0.979925 ,	0.980271 ,	0.980615 ,	0.980955 ,	0.981293 ,
	0.981627 ,	0.981959 ,	0.982287 ,	0.982613 ,	0.982935 ,	0.983255 ,	0.983571 ,	0.983885 ,	0.984196 ,	0.984503 ,
	0.984808 ,	0.985109 ,	0.985408 ,	0.985703 ,	0.985996 ,	0.986286 ,	0.986572 ,	0.986856 ,	0.987136 ,	0.987414 ,
	0.987688 ,	0.987960 ,	0.988228 ,	0.988494 ,	0.988756 ,	0.989016 ,	0.989272 ,	0.989526 ,	0.989776 ,	0.990024 ,
	0.990268 ,	0.990509 ,	0.990748 ,	0.990983 ,	0.991216 ,	0.991445 ,	0.991671 ,	0.991894 ,	0.992115 ,	0.992332 ,
	0.992546 ,	0.992757 ,	0.992966 ,	0.993171 ,	0.993373 ,	0.993572 ,	0.993768 ,	0.993961 ,	0.994151 ,	0.994338 ,
	0.994522 ,	0.994703 ,	0.994881 ,	0.995056 ,	0.995227 ,	0.995396 ,	0.995562 ,	0.995725 ,	0.995884 ,	0.996041 ,
	0.996195 ,	0.996345 ,	0.996493 ,	0.996637 ,	0.996779 ,	0.996917 ,	0.997053 ,	0.997185 ,	0.997314 ,	0.997441 ,
	0.997564 ,	0.997684 ,	0.997801 ,	0.997916 ,	0.998027 ,	0.998135 ,	0.998240 ,	0.998342 ,	0.998441 ,	0.998537 ,
	0.998630 ,	0.998719 ,	0.998806 ,	0.998890 ,	0.998971 ,	0.999048 ,	0.999123 ,	0.999194 ,	0.999263 ,	0.999328 ,
	0.999391 ,	0.999450 ,	0.999507 ,	0.999560 ,	0.999610 ,	0.999657 ,	0.999701 ,	0.999743 ,	0.999781 ,	0.999816 ,
	0.999848 ,	0.999877 ,	0.999903 ,	0.999925 ,	0.999945 ,	0.999962 ,	0.999976 ,	0.999986 ,	0.999994 ,	0.999998 ,
	1.000000
};

//----------------------------------------------------------------------------------
//-------------------------------------------------------------------------
//void rotate( double x , double y , double cx , double cy , double theta , double *x2 , double *y2 ) {
////	#define	PIE_VALUE	3.14159265/180
//	#define	PIE_VALUE	0.0174532925
//	double	PIE_VALUE2	= PIE_VALUE * theta;
//	*x2 = (x-cx) * cos( PIE_VALUE2 ) + (y-cy) * sin( PIE_VALUE2 ) + cx;
//	*y2 = (y-cy) * cos( PIE_VALUE2 ) - (x-cx) * sin( PIE_VALUE2 ) + cy;
//}


//============================================
// Change 2002.03.25 // for fast
//============================================
void rotate( double x , double y , double cx , double cy , double theta , double *x2 , double *y2 ) {
	int ith;
	ith = (int) ( theta * (double) 10 );
	if ( ( ith > 3600 ) || ( ith < -3600 ) ) ith = ith % 3600;
	if      ( ( ith >=    0 ) && ( ith <=  900 ) ) {
		*x2 = (x-cx) * memsin[ 900 - ith ] + (y-cy) * memsin[ ith ] + cx;
		*y2 = (y-cy) * memsin[ 900 - ith ] - (x-cx) * memsin[ ith ] + cy;
	}
	else if ( ( ith >=  900 ) && ( ith <= 1800 ) ) {
		*x2 = (x-cx) * - memsin[ ith - 900 ] + (y-cy) * memsin[ 1800 - ith ] + cx;
		*y2 = (y-cy) * - memsin[ ith - 900 ] - (x-cx) * memsin[ 1800 - ith ] + cy;
	}
	else if ( ( ith >= 1800 ) && ( ith <= 2700 ) ) {
		*x2 = (x-cx) * - memsin[ 2700 - ith ] + (y-cy) * - memsin[ ith - 1800 ] + cx;
		*y2 = (y-cy) * - memsin[ 2700 - ith ] - (x-cx) * - memsin[ ith - 1800 ] + cy;
	}
	else if ( ( ith >= 2700 ) && ( ith <= 3600 ) ) {
		*x2 = (x-cx) * memsin[ ith - 2700 ] + (y-cy) * - memsin[ 3600 - ith ] + cx;
		*y2 = (y-cy) * memsin[ ith - 2700 ] - (x-cx) * - memsin[ 3600 - ith ] + cy;
	}
	else if ( ( ith >= -900 ) && ( ith <= 0 ) ) {
		*x2 = (x-cx) * memsin[ 900 + ith ] + (y-cy) * - memsin[ - ith ] + cx;
		*y2 = (y-cy) * memsin[ 900 + ith ] - (x-cx) * - memsin[ - ith ] + cy;
	}
	else if ( ( ith >= -1800 ) && ( ith <= -900 ) ) {
		*x2 = (x-cx) * - memsin[ - ith - 900 ] + (y-cy) * - memsin[ 1800 + ith ] + cx;
		*y2 = (y-cy) * - memsin[ - ith - 900 ] - (x-cx) * - memsin[ 1800 + ith ] + cy;
	}
	else if ( ( ith >= -2700 ) && ( ith <= -1800 ) ) {
		*x2 = (x-cx) * - memsin[ 2700 + ith ] + (y-cy) * memsin[ - ith - 1800 ] + cx;
		*y2 = (y-cy) * - memsin[ 2700 + ith ] - (x-cx) * memsin[ - ith - 1800 ] + cy;
	}
	else if ( ( ith >= -3600 ) && ( ith <= -2700 ) ) {
		*x2 = (x-cx) * memsin[ - ith - 2700 ] + (y-cy) * memsin[ 3600 + ith ] + cx;
		*y2 = (y-cy) * memsin[ - ith - 2700 ] - (x-cx) * memsin[ 3600 + ith ] + cy;
	}
}
//
//
//
enum { DRAW_LINE , DRAW_POLYGON  , DRAW_CIRCLE , DRAW_TEXT };

#define IMAGE_OBJECT_SIZE		97
#define IMAGE_POINT_SIZE		20

typedef struct _IMAGE_TABLE {
	int			Type;
	int			Pointer;
	BOOL		Use;
} _IMAGE_TABLE;

typedef struct _IMAGE_CIRCLE_TABLE {
	int			fcolor;
	int			ecolor;
	double		Point_X;
	double		Point_Y;
	double		Point_XS;
	double		Point_YS;
} _IMAGE_CIRCLE_TABLE;

typedef struct _IMAGE_LINE_TABLE {
	int			ecolor;
	double		Point_X1;
	double		Point_Y1;
	double		Point_X2;
	double		Point_Y2;
} _IMAGE_LINE_TABLE;

typedef struct _IMAGE_POLYGON_TABLE {
	int			fcolor;
	int			ecolor;
	int			len;
	double		Point_X[IMAGE_POINT_SIZE];
	double		Point_Y[IMAGE_POINT_SIZE];
} _IMAGE_POLYGON_TABLE;

typedef struct _IMAGE_TEXT_TABLE {
	int			tcolor;
	int			bcolor;
	double		Point_X;
	double		Point_Y;
	double		Point_XS;
	double		Point_YS;
	char        *format;
	int			size;
	int			datap;
	int			option;
} _IMAGE_TEXT_TABLE;

_IMAGE_LINE_TABLE	IMAGE_LINE_TABLE[] = {
		0 ,		0.0   , 0.0  , 0.0 , 0.0 
};

_IMAGE_TEXT_TABLE	IMAGE_TEXT_TABLE[] = {
		219 ,	  0   ,  -5.0 , -3.0 , -0.5  ,  1.0 , "%c" , 13 , -1 , 'A' ,
		219 ,	  0   ,  5.0  , -3.0 , -0.5  ,  1.0 , "%c" , 13 , -1 , 'A' ,
		0 ,		  0   ,  0.0  , -4.0 , -1.8  ,  1.2 , "%c" , 20 ,  2 , 'A' ,
		0 ,		  0   ,  0.0  , -4.0 , -0.5  ,  1.2 , "%d" , 20 ,  0 ,  0  ,

		0 ,		  0   ,  0.0  , -7.0 , -1.8  ,  1.2 , "%c" , 20 ,  3 , 'A' ,
		0 ,		  0   ,  0.0  , -7.0 , -0.5  ,  1.2 , "%d" , 20 ,  1 ,  0  ,

		220 ,	  0   ,  -5.0 , -5.0 , -0.5  ,  1.0 , "%c" , 13 , -1 , 'B' ,
		220 ,	  0   ,  5.0  , -5.0 , -0.5  ,  1.0 , "%c" , 13 , -1 , 'B' ,
	
};

_IMAGE_CIRCLE_TABLE	IMAGE_CIRCLE_TABLE[] = {
		42	,	16	,		-5.0   ,  0  ,  1.9  , 1.9  ,//Main Plate1

		12	,	57	,		-5.0   ,  0  , 1.84  , 1.84 ,
		13	,	7	,		-5.0   ,  0  , 1.4   , 1.4  ,
		12	,	57	,		-9.16  ,  0  , 1.4   , 1.4  , 

		12	,	57	,		-5.0   ,  0  ,  1.15 , 1.15 ,
		12	,	57	,		-9.16  ,  0  ,  1.15 , 1.15 ,
		13	,	7	,		-9.16  ,  0  ,  0.9  , 0.9  ,

		//7
		44	,	7	,		-5.4   ,  -1.7 , 0.25  , 0.25 , //fork A left bottom
		44	,	7	,		-4.6   ,  -1.7 , 0.25  , 0.25 , //fork A right bottom
		44	,	7	,		-6.6  ,  -6.5 , 0.25  , 0.25 , //fork A left top
		44	,	7	,		-3.4   ,  -6.5 , 0.25  , 0.25 , //fork A right top

		//11
		44	,	7	,		 5.4   ,  -1.7 , 0.25  , 0.25 , //fork B left bottom
		44	,	7	,		 4.6   ,  -1.7 , 0.25  , 0.25 , //fork B right bottom
		44	,	7	,		 6.6  ,  -6.5 , 0.25  , 0.25 , //fork B left top
		44	,	7	,		 3.4   ,  -6.5 , 0.25  , 0.25 , //fork B right top

		//15
		12	,	57	,		-5.0   ,  0  ,  0.9  ,  0.9 ,
		13	,	7	,		-5.0   ,  0  ,  0.6  ,  0.6 ,

		//Wafer Circle 17
		108	,	110	,		 0.0  ,  -4.5 ,  2.7  ,  2.7 , // 17
		108	,	110 ,		 0.0  ,  -6.5 ,  2.7  ,  2.7 , // 18

		//19
		12	,	57	,		-5.0   ,  0 , 1.15  , 1.15  ,
		13	,	7	,		-5.0   ,  0 , 0.9   , 0.9   ,
		42	,	16	,		5.0   ,  0 , 1.9   , 1.9   , //21 Main Plate2
		12	,	57	,		5.0    ,  0 , 1.84  , 1.84  , //Arm 1-1 Circle
		13	,	7	,		5.0   ,  0 , 1.4   , 1.4   ,
		12	,	57	,		9.16   ,  0 , 1.4   , 1.4   , 

		//25
		12	,	57	,		5.0    ,  0 , 1.15    , 1.15  , //Arm2-1 Circle
		12	,	57	,		9.16   ,  0 , 1.15    , 1.15  ,
		13	,	7	,		9.16   ,  0 , 0.9     , 0.9   ,
		42	,	16	,		0.0    ,  0.0 , 9     , 9     , //28 Main Axis
		12	,	57	,		0.0    ,  0.0 , 8.5   , 8.5   ,
		13	,	7	,		0.0    ,  0.0 , 8.0   , 8.0   ,

		//Arm 3/4
		44	,	16	,		-5.0   ,  -2.0  , 1.9  , 1.9   , //31 Main plate1 of robot2
		44	,	16	,		5.0    ,  -2.0  , 1.9  , 1.9  ,  //32 Main Plate2 of robot2
		//33 robot2 arm
		15	,	57	,		-5.0   ,  -2.0  , 1.84  , 1.84 ,
		16	,	7	,		-5.0   ,  -2.0  , 1.4   , 1.4  ,
		15	,	57	,		-9.16  ,  -2.0  , 1.4   , 1.4  , 

		15	,	57	,		-5.0   ,  -2.0  ,  1.15 , 1.15 ,
		15	,	57	,		-9.16  ,  -2.0  ,  1.15 , 1.15 ,
		16	,	7	,		-9.16  ,  -2.0  ,  0.9  , 0.9  ,

		//39
		15	,	57	,		5.0    ,  -2.0 , 1.84  , 1.84  , 
		16	,	7	,		5.0    ,  -2.0 , 1.4   , 1.4   ,
		15	,	57	,		9.16   ,  -2.0 , 1.4   , 1.4   , 

		15	,	57	,		5.0    ,  -2.0 , 1.15  , 1.15  , 
		15	,	57	,		9.16   ,  -2.0 , 1.15  , 1.15  ,
		16	,	7	,		9.16   ,  -2.0 , 0.9   , 0.9   ,

		//45
		47	,	7	,		-5.4   ,  -3.7 , 0.25   , 0.25 , //fork A left bottom of robot2
		47	,	7	,		-4.6   ,  -3.7 , 0.25   , 0.25 , //fork A right bottom of robot2
		47	,	7	,		-6.6   ,  -8.5 , 0.25  , 0.25 , //fork A left top of robot2
		47	,	7	,		-3.4   ,  -8.5 , 0.25  , 0.25 , //fork A right top of robot2

		//49
		47	,	7	,		 5.4  ,  -3.7 , 0.25  , 0.25 , //fork B left bottom of robot2
		47	,	7	,		 4.6  ,  -3.7 , 0.25  , 0.25 , //fork B right bottom of robot2
		47	,	7	,		 6.6  ,  -8.5 , 0.25  , 0.25 , //fork B left top of robot2
		47	,	7	,		 3.4  ,  -8.5 , 0.25  , 0.25 ,  //fork B right top of robot2

		//20070830 mgsong
		108	,	110	,		 2.5  ,  -4.5 ,  2.7  ,  2.7 , // 53
		108	,	110 ,		 2.5  ,  -8.5 ,  2.7  ,  2.7  // 54
};


_IMAGE_POLYGON_TABLE	IMAGE_POLYGON_TABLE[] = {
		38 , 16 , 5 , //Arm A Left Arm
            -9.16 , -5.0  , -5.0 , -9.16 , -9.16 , 0 , 0 , 0 , 0 , 0 ,	0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ,
			-1.4  , -1.84 , 1.84, 1.4  , -1.4  , 0 , 0 , 0 , 0 , 0 ,	0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ,

		36 , 36 , 4 ,
            -6.99 , -6.99  , -8.5  , -8.5  , 0 , 0 , 0 , 0 , 0 , 0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ,
			-0.83 , 0.83   , 0.83  , -0.83 , 0 , 0 , 0 , 0 , 0 , 0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ,

		34 , 34 , 4 ,
            -7.45 , -7.45 , -8.05, -8.05 , 0 , 0 , 0 , 0 , 0 , 0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ,
			-0.37 , 0.37 , 0.37, -0.37 , 0 , 0 , 0 , 0 , 0 , 0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ,

		37 , 16 , 4 ,
            -9.16 , -9.16 , -5.0 , -5.0 , 0 , 0 , 0 , 0 , 0 , 0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ,
			-1.2  , 1.2   , 1.2  , -1.2 , 0 , 0 , 0 , 0 , 0 , 0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ,

		35 , 35 , 4 ,
            -7.8  , -7.8  , -6.35 , -6.35, 0 , 0 , 0 , 0 , 0 , 0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ,
			-0.75 , 0.75 , 0.75 , -0.75, 0 , 0 , 0 , 0 , 0 , 0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ,

		33 , 33 , 4 ,
            -7.5  , -7.5  , -6.65, -6.65, 0 , 0 , 0 , 0 , 0 , 0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ,
			-0.32 , 0.32 , 0.32 , -0.32, 0 , 0 , 0 , 0 , 0 , 0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ,
			

		39 , 55 , 4 ,//arm fork connector
            -5.9  ,  -5.9 , -4.1 , -4.1   , 0 , 0 , 0 , 0 , 0 , 0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ,
			-1.15 ,  0 , 0 , -1.15  , 0 , 0 , 0 , 0 , 0 , 0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ,

		37 , 57 , 20 ,//fork 
			-4.5   , -3.83, -3.83,  -3.6   ,  -3.2 ,  -2.97 ,  -2.97, -3.8  , -3.8  ,   -4.6 ,  -5.4 ,  -6.2 , -6.2  , -7.03 , -7.03 , -6.8  , -6.4 , -6.17 , -6.17 , -5.5 ,
			-4.1   , -4.5 , -6.7 , -6.93 , -6.9 , -6.75 ,  -4.0 , -3.36 , -1.65 , -1.15  , -1.15 , -1.65 , -3.36 , -4.0  , -6.75 , -6.9  , -6.9 , -6.75 , -4.5  , -4.1 ,

		36 , 36 , 12 ,//
			-7.2145 , -7.2145 , -6.2716 , -6.2716 , -5.9887 , -5.0457 , -5.0457 , -5.6115 , -5.6115 , -6.8373 , -7.0259 , -7.0259 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
			-5.5589 , -4.187  , -3.3956 , -2.182  , -1.7335 , -1.7335 , -2.2084 , -2.8416 , -3.422  , -4.1343 , -4.4245 , -5.5061 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,

		34 , 34 , 7 ,//
			-6.0515 , -6.083  , -5.8315	, -5.36   , -5.3915 , -5.6743 , -5.7058 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 
			-3.3165 , -2.3139 , -1.8654	, -1.8654 , -2.2084 , -2.5778 , -3.3165 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,

		-1 , 14 , 18 ,
			-3.33  , -3.5  , -3.7  , -3.9  , -4.1  , -4.7  , -4.5  , -4.7  , -4.9  , -5.1  , -5.3  , -5.5  , -5.7  , -5.9  , -6.1 ,  -6.3 ,  -6.5 , -6.67 , 0 , 0 ,
			-3.36  , -3.25 , -3.17 , -3.10 , -3.04 , -2.99 , -2.95 , -2.92 , -2.90 , -2.90 , -2.92 , -2.95 , -2.99 , -3.04 , -3.10 , -3.17 , -3.25 , -3.36 , 0 , 0 ,

			
		39 , 55 , 4 ,//arm fork B connector
            5.9   ,  5.9  , 4.1  , 4.1    , 0 , 0 , 0 , 0 , 0 , 0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ,
			-1.15 ,  0 , 0 , -1.15  , 0 , 0 , 0 , 0 , 0 , 0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ,

		37 , 57 , 20 ,//fork B
			4.5    ,  3.83  ,  3.83  ,   3.6  ,  3.2  ,  2.97  ,  2.97 , 3.8   , 3.8   ,   4.6  ,  5.4  ,  6.2  , 6.2   , 7.03  , 7.03  , 6.8   , 6.4  , 6.17  , 6.17  , 5.5 ,
			-4.1   ,  -4.5  ,  -6.7  , -6.93  , -6.9  , -6.75  ,  -4.0 , -3.36 , -1.65 , -1.15  , -1.15 , -1.65 , -3.36 , -4.0  , -6.75 , -6.9  , -6.9 , -6.75 , -4.5  , -4.1 ,

		36 , 36 , 12 ,//
			7.2145  , 7.2145  , 6.2716  , 6.2716  , 5.9887  , 5.0457  , 5.0457  , 5.6115  , 5.6115  , 6.8373  , 7.0259  , 7.0259  , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
			-5.5589 , -4.187  , -3.3956 , -2.182  , -1.7335 , -1.7335 , -2.2084 , -2.8416 , -3.422  , -4.1343 , -4.4245 , -5.5061 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,

		34 , 34 , 7 ,//
			6.0515  , 6.083   , 5.8315	, 5.36    , 5.3915  , 5.6743  , 5.7058  , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 
			-3.3165 , -2.3139 , -1.8654	, -1.8654 , -2.2084 , -2.5778 , -3.3165 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,

		-1 , 14 , 18 ,
			3.33   ,   3.5   ,   3.7  ,   3.9  ,   4.1  ,   4.7  ,   4.5  ,   4.7  ,   4.9  ,  5.1  ,  5.3  ,  5.5  ,  5.7  ,  5.9  ,  6.1  ,  6.3  ,  6.5  , 6.67  , 0 , 0 ,
			-3.36  , -3.25   , -3.17  , -3.10  , -3.04  , -2.99  , -2.95  , -2.92  , -2.90  , -2.90 , -2.92 , -2.95 , -2.99 , -3.04 , -3.10 , -3.17 , -3.25 , -3.36 , 0 , 0 ,


		39 , 55 , 4 ,
             -5.0 ,  -4.0 , -4.0 , 0.0 , 0 , 0 , 0 , 0 , 0 , 0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ,
			-0.8  , -0.8  , 0.8  , 0.8 , 0 , 0 , 0 , 0 , 0 , 0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ,

		//Wafer Mask
		107 , 107 , 11 , // 17
			 0.6792  , 0.9678  , 1.7642  , 1.6658 , 0.4082  , -1.0174 , -2.0547 , -2.0772 , -1.1816 , 0.4377  , 0.7275  , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
			 -6.4514  , -5.3632  , -4.5403  , -3.235  , -2.4389  , -2.5616 , -4.9408 , -5.2946 , -6.3813 , -6.6209  , -6.4272 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,

		106 , 106 , 10 , // 18
			0.8441  , 1.0629  , 0.3385  , -0.0712 , -0.5536 , -1.4245 , -1.6678 , -1.1133 , -0.2196 , 0.9163  , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
			-3.1877  , -4.1302  , -4.5663  , -5.4854 , -6.2112 , -5.4388 , -4.2062 , -3.166  , -2.8264 , -2.9459 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,

		105 , 105 , 7 , // 19
			-0.5065 , -0.0487 , 0.192  , -1.0405 , -1.3776 , -1.2315 , -0.7478 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
			-5.1959 , -4.1558 , -3.4544 , -3.3835 , -4.3267 , -5.221  , -5.4863 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,

		107 , 107 , 11 , // 20
			 0.6792  , 0.9678  , 1.7642  , 1.6658 , 0.4082  , -1.0174 , -2.0547 , -2.0772 , -1.1816 , 0.4377  , 0.7275  , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
			 -10.4514  , -9.3632  , -8.5403  , -7.235  , -6.4389  , -6.5616  , -7.9408  ,  -9.2946 ,  -10.3813 , -10.6209  , -10.4272 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,

		106 , 106 , 10 , // 21
			0.8441  , 1.0629  , 0.3385  , -0.0712 , -0.5536 , -1.4245 , -1.6678 , -1.1133 , -0.2196 , 0.9163  , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
			-7.1877  , -8.1302  , -8.5663  ,  -9.4854 ,  -10.2112 ,  -9.4388 ,  -8.2062 ,  -7.166  ,  -6.8264 , -6.9459 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,

		105 , 105 , 7 , // 22
			-0.5065 , -0.0487 , 0.192  , -1.0405 , -1.3776 , -1.2315 , -0.7478 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
			 -9.1959 ,  -8.1558 , -7.4544 ,  -7.3835 ,  -8.3267 ,  -9.221  ,  -9.4863 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
		

		108 , 110 , 4 , // 23 // Mask A
			 -2.7 , -2.7 , 2.7 , 2.7 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
			 -2.8 , -8.2 , -8.2 , -2.8 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
		108 , 110 , 4 , // 24 // Mask B
			  -2.7 , -2.7 , 2.7 , 2.7 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
			   -6.8 ,  -12.2 ,  -12.2 ,  -6.8 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,

		
		108 , 110 , 4 , // 25 // Mask A
			 -7.9 , -7.9 ,  -2.1 , -2.1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
			 -8.5 , -11.5 , -11.5  , -6.5 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
		108 , 110 , 4 , // 26 // Mask B
			  7.9  ,  7.9  ,  2.1  ,  2.1  , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
			  -6.5 ,  -11.5 ,  -11.5 ,  -6.5 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
		108 , 110 , 4 , // 27 // Mask A
			 -7.5 , -7.5 ,  -2.5 ,  -2.5 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
			 -6.1 , -11.9 , -11.9 , -6.1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
		108 , 110 , 4 , // 28 // Mask B
			  7.5  ,  7.5  ,  2.5  ,  2.5  , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
			  -6.1 ,  -11.9 ,  -11.9 ,  -6.1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
		108 , 110 , 4 , // 29 // Mask A
			 -8.1 , -8.1 ,  -1.9 ,  -1.9 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
			 -6.7 , -11.3 , -11.3 , -6.7 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
		108 , 110 , 4 , // 30 // Mask B
			  8.1  ,  8.1  ,  1.9  ,  1.9  , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
			  -6.7 ,  -11.3 ,  -11.3 ,  -6.7 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
		108 , 110 , 4 , // 31 // Mask A
			 -7.3 , -7.3 ,  -2.7 ,  -2.7 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
			 -5.9 , -12.1 , -12.1 , -5.9 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
		108 , 110 , 4 , // 32 // Mask B
			  7.3  ,  7.3  ,  2.7  ,  2.7  , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,
			  -5.9 ,  -12.1 ,  -12.1 ,  -5.9 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0,
			  
		38 , 16 , 5 ,//ARM 1-1 Polygon
            9.16  ,  5.0  ,  5.0   , 9.16  , 9.16  , 0 , 0 , 0 , 0 , 0 ,	0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ,
			-1.4  , -1.84 ,  1.84  ,  1.4  , -1.4  , 0 , 0 , 0 , 0 , 0 ,	0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ,

		36 , 36 , 4 ,
            6.99  , 6.99  , 8.5  , 8.5   , 0 , 0 , 0 , 0 , 0 , 0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ,
			-0.83 , 0.83  , 0.83 , -0.83 , 0 , 0 , 0 , 0 , 0 , 0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ,

		34 , 34 , 4 ,
            7.45  , 7.45  , 8.05  , 8.05  , 0 , 0 , 0 , 0 , 0 , 0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ,
			-0.37 ,  0.37 ,  0.37 , -0.37 , 0 , 0 , 0 , 0 , 0 , 0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ,
			
		37 , 16 , 4 , //ARM 2-1 Polygon
            9.16  , 9.16  , 5.0  , 5.0  , 0 , 0 , 0 , 0 , 0 , 0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ,
			-1.2  ,   1.2 , 1.2  , -1.2 , 0 , 0 , 0 , 0 , 0 , 0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ,

		35 , 35 , 4 ,
            7.8   , 7.8  , 6.35  , 6.35  , 0 , 0 , 0 , 0 , 0 , 0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ,
			-0.75 , 0.75 , 0.75  , -0.75 , 0 , 0 , 0 , 0 , 0 , 0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ,

		33 , 33 , 4 ,
            7.5   , 7.5   , 6.65  , 6.65   , 0 , 0 , 0 , 0 , 0 , 0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ,
			-0.32 , 0.32  , 0.32  , -0.32  , 0 , 0 , 0 , 0 , 0 , 0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0,

		///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//39 robot 2 polygon
		41 , 16 , 5 , //Arm A Left Arm
            -9.16 , -5.0  , -5.0 , -9.16 , -9.16 , 0 , 0 , 0 , 0 , 0 ,	0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ,
			-3.4  , -3.84  , -0.16 , -0.6   , -3.4   , 0 , 0 , 0 , 0 , 0 ,	0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ,

		39 , 36 , 4 ,
            -6.99 , -6.99  , -8.5  , -8.5  , 0 , 0 , 0 , 0 , 0 , 0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ,
			 -2.83 ,  -1.17  ,  -1.17 ,  -2.83 , 0 , 0 , 0 , 0 , 0 , 0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ,

		37 , 34 , 4 ,
            -7.45 , -7.45 , -8.05, -8.05 , 0 , 0 , 0 , 0 , 0 , 0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ,
			 -2.37 ,  -1.63 ,  -1.63,  -2.37 , 0 , 0 , 0 , 0 , 0 , 0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ,

			
		40 , 16 , 4 ,
            -9.16 , -9.16 , -5.0 , -5.0 , 0 , 0 , 0 , 0 , 0 , 0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ,
			 -3.2  ,  -0.8  ,  -0.8 ,  -3.2 , 0 , 0 , 0 , 0 , 0 , 0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ,

		38 , 35 , 4 ,
            -7.8  , -7.8  , -6.35 , -6.35, 0 , 0 , 0 , 0 , 0 , 0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ,
		     -2.75 ,  -1.25 ,  -1.25 ,  -2.75, 0 , 0 , 0 , 0 , 0 , 0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ,

		36 , 33 , 4 ,
            -7.5  , -7.5  , -6.65, -6.65, 0 , 0 , 0 , 0 , 0 , 0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ,
			 -2.32 ,  -1.68 ,  -2.68 , -2.32, 0 , 0 , 0 , 0 , 0 , 0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ,

		//45 robot 2 arm 2 polygon
		41 , 16 , 5 ,
            9.16  ,  5.0  ,  5.0   , 9.16  , 9.16  , 0 , 0 , 0 , 0 , 0 ,	0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ,
			-3.4   , -3.84  ,  -0.16  ,  -0.6  , -3.4   , 0 , 0 , 0 , 0 , 0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ,

		39 , 36 , 4 ,
            6.99  , 6.99  , 8.5  , 8.5   , 0 , 0 , 0 , 0 , 0 , 0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ,
			-2.83  , -1.17  , -1.17 , -2.83  , 0 , 0 , 0 , 0 , 0 , 0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ,

		37 , 34 , 4 ,
            7.45  , 7.45  , 8.05  , 8.05  , 0 , 0 , 0 , 0 , 0 , 0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ,
			-2.37  , -1.63 ,  -1.63 , -2.37  , 0 , 0 , 0 , 0 , 0 , 0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ,

		40 , 16 , 4 , 
            9.16  , 9.16  , 5.0  , 5.0  , 0 , 0 , 0 , 0 , 0 , 0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ,
			-3.2   , -0.8 , -0.8  , -3.2  , 0 , 0 , 0 , 0 , 0 , 0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ,

		38 , 35 , 4 ,
            7.8   , 7.8  , 6.35  , 6.35  , 0 , 0 , 0 , 0 , 0 , 0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ,
			-2.75  , -1.25 , -1.25  , -2.75  , 0 , 0 , 0 , 0 , 0 , 0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ,

		36 , 33 , 4 ,
            7.5   , 7.5   , 6.65  , 6.65   , 0 , 0 , 0 , 0 , 0 , 0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ,
			-2.32  , -1.68  , -1.68  , -2.32  , 0 , 0 , 0 , 0 , 0 , 0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0,

		//51
		42 , 55 , 4 ,//arm fork connector of robot2
            -5.9  ,  -5.9 , -4.1 , -4.1   , 0 , 0 , 0 , 0 , 0 , 0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ,
			 -3.15 ,   -2.0 ,  -2.0 ,  -3.15  , 0 , 0 , 0 , 0 , 0 , 0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ,

		40 , 57 , 20 ,//fork of robot 2
			-4.5   , -3.83, -3.83,  -3.6   ,  -3.2 ,  -2.97 ,  -2.97, -3.8  , -3.8  ,   -4.6 ,  -5.4 ,  -6.2 , -6.2  , -7.03 , -7.03 , -6.8  , -6.4 , -6.17 , -6.17 , -5.5 ,
			 -6.1   ,  -6.5 ,  -8.7 ,   -8.93  ,   -8.9 ,   -8.75 ,   -6.0 ,  -5.36 ,  -3.65 ,    -3.15  , -3.15 ,  -3.65 , -5.36 ,  -6.0  ,  -8.75 ,  -8.9  ,  -8.9 ,  -8.75 ,  -6.5  ,  -6.1 ,

        //53
		42 , 55 , 4 ,//arm fork B connector of robot2
            5.9   ,  5.9  , 4.1  , 4.1   , 0 , 0 , 0 , 0 , 0 , 0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ,
			-3.15  ,  -2.0  , -2.0  , -3.15  , 0 , 0 , 0 , 0 , 0 , 0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 ,

		40 , 57 , 20 ,//fork B of robot2
			4.5   ,  3.83  ,  3.83  , 3.6  ,  3.2  ,  2.97  ,  2.97 , 3.8   , 3.8   , 4.6  ,  5.4  ,  6.2  , 6.2  , 7.03  , 7.03  , 6.8   , 6.4  , 6.17  , 6.17  , 5.5 ,
			-6.1   ,  -6.5   ,  -8.7   , -8.93 ,  -8.9  ,  -8.75  ,  -6.0  , -5.36  , -3.65  , -3.15 ,  -3.15 ,  -3.65 , -5.36 , -6.0   , -8.75  , -8.9   , -8.9  , -8.75  , -6.5   , -6.1
};


_IMAGE_TABLE	IMAGE_TABLE[] = {
	//0 Main Axis
	    DRAW_CIRCLE  ,  28 , TRUE,
		DRAW_CIRCLE  ,  29 , TRUE,
		DRAW_CIRCLE  ,  30 , TRUE,
	//3 Full Rotate Plate1
		DRAW_CIRCLE  ,	0 , TRUE ,
	//4 Full Rotate Plate2
		DRAW_CIRCLE  ,	21, TRUE ,
	//5 Arm 1 --> Arm Hole 위치및 길이 -4씩 감소
		DRAW_POLYGON , 	0 , TRUE ,
		DRAW_POLYGON , 	1 , TRUE ,
		DRAW_POLYGON , 	2 , TRUE ,
		DRAW_CIRCLE  , 	1 , TRUE ,
		DRAW_CIRCLE  , 	2 , TRUE ,
		DRAW_CIRCLE  , 	3 , TRUE ,
	//11 Arm 1 --> Arm Hole 위치및 길이 -4씩 감소
		DRAW_POLYGON , 	3 , TRUE ,
		DRAW_POLYGON , 	4 , TRUE ,
		DRAW_POLYGON , 	5 , TRUE ,
		DRAW_CIRCLE  , 	4 , TRUE ,
		DRAW_CIRCLE  , 	5 , TRUE ,
		DRAW_CIRCLE  , 	6 , TRUE ,

	//mgsong temp
	//17 Arm 2 
		DRAW_POLYGON , 	33 , TRUE ,
		DRAW_POLYGON , 	34 , TRUE ,
		DRAW_POLYGON , 	35 , TRUE ,
		DRAW_CIRCLE  , 	22 , TRUE ,
		DRAW_CIRCLE  , 	23 , TRUE ,
		DRAW_CIRCLE  , 	24 , TRUE ,
	// 23 Arm 2
		DRAW_POLYGON , 	36 , TRUE ,
		DRAW_POLYGON , 	37 , TRUE ,
		DRAW_POLYGON , 	38 , TRUE ,
		DRAW_CIRCLE  , 	25 , TRUE ,
		DRAW_CIRCLE  , 	26 , TRUE ,
		DRAW_CIRCLE  , 	27 , TRUE ,

	 //29 Fork A of robot1
		DRAW_POLYGON , 	6  , TRUE ,
		DRAW_POLYGON , 	7  , TRUE ,
		DRAW_CIRCLE  , 	7  , TRUE ,
		DRAW_CIRCLE  , 	8  , TRUE ,
		DRAW_CIRCLE  , 	9  , TRUE ,
		DRAW_CIRCLE  , 	10 , TRUE ,
		DRAW_TEXT	 , 	0  , TRUE ,
		
	//36 Fork B of robot1
		DRAW_POLYGON , 	11 , TRUE ,
		DRAW_POLYGON , 	12 , TRUE ,
		DRAW_CIRCLE , 	11 , TRUE ,
		DRAW_CIRCLE , 	12 , TRUE ,
		DRAW_CIRCLE , 	13 , TRUE ,
		DRAW_CIRCLE , 	14 , TRUE ,
		DRAW_TEXT	, 	 1 , TRUE ,

	//20070123 a pair of arm is added
	//43 Full Rotate Plate1 of robot2
		DRAW_CIRCLE  ,	31 , TRUE ,
	//44 Full Rotate Plate2 of robot2
		DRAW_CIRCLE  ,	32, TRUE ,
	//45 Arm1 of robot2
		DRAW_POLYGON , 	39 , TRUE ,
		DRAW_POLYGON , 	40 , TRUE ,
		DRAW_POLYGON , 	41 , TRUE ,
		DRAW_CIRCLE  , 	33 , TRUE ,
		DRAW_CIRCLE  , 	34 , TRUE ,
		DRAW_CIRCLE  , 	35 , TRUE ,
	//51 ankle Arm1 of robot 2
		DRAW_POLYGON , 	42 , TRUE ,
		DRAW_POLYGON , 	43 , TRUE ,
		DRAW_POLYGON , 	44 , TRUE ,
		DRAW_CIRCLE  , 	36 , TRUE ,
		DRAW_CIRCLE  , 	37 , TRUE ,
		DRAW_CIRCLE  , 	38 , TRUE ,
	//57 Arm 2 of robot 2
		DRAW_POLYGON , 	45 , TRUE ,
		DRAW_POLYGON , 	46 , TRUE ,
		DRAW_POLYGON , 	47 , TRUE ,
		DRAW_CIRCLE  , 	39 , TRUE ,
		DRAW_CIRCLE  , 	40 , TRUE ,
		DRAW_CIRCLE  , 	41 , TRUE ,
	// 63 ankle Arm2 of robot 2
		DRAW_POLYGON , 	48 , TRUE ,
		DRAW_POLYGON , 	49 , TRUE ,
		DRAW_POLYGON , 	50 , TRUE ,
		DRAW_CIRCLE  , 	42 , TRUE ,
		DRAW_CIRCLE  , 	43 , TRUE ,
		DRAW_CIRCLE  , 	44 , TRUE ,

	//69 Fork A of robot2
		DRAW_POLYGON , 	51  , TRUE ,
		DRAW_POLYGON , 	52  , TRUE ,
		DRAW_CIRCLE  , 	45  , TRUE ,
		DRAW_CIRCLE  , 	46  , TRUE ,
		DRAW_CIRCLE  , 	47  , TRUE ,
		DRAW_CIRCLE  , 	48 , TRUE ,
		DRAW_TEXT	 , 	6  , TRUE ,
		
	//76 Fork B of robot2
		DRAW_POLYGON , 	53 , TRUE ,
		DRAW_POLYGON , 	54 , TRUE ,
		DRAW_CIRCLE , 	49 , TRUE ,
		DRAW_CIRCLE , 	50 , TRUE ,
		DRAW_CIRCLE , 	51 , TRUE ,
		DRAW_CIRCLE , 	52 , TRUE ,
		DRAW_TEXT	, 	 7 , TRUE ,

	//83 Wafer A Arm
		DRAW_CIRCLE , 	17 , TRUE ,	// Wafer
		DRAW_POLYGON , 	23 , TRUE ,	// Mask44
		DRAW_POLYGON , 	17 , TRUE ,
		DRAW_POLYGON ,	18 , TRUE ,
		DRAW_POLYGON , 	19 , TRUE ,
		DRAW_TEXT	 , 	 2 , TRUE ,
		DRAW_TEXT	 , 	 3 , TRUE ,
	//90 Wafer B Arm
		DRAW_CIRCLE , 	18 , TRUE ,	// Wafer
		DRAW_POLYGON , 	24 , TRUE ,	// Mask51
		DRAW_POLYGON , 	20 , TRUE ,
		DRAW_POLYGON , 	21 , TRUE ,
		DRAW_POLYGON , 	22 , TRUE ,
		DRAW_TEXT	 , 	 4 , TRUE ,
		DRAW_TEXT	 , 	 5 , TRUE 
};

double Point_Buffer_x[IMAGE_OBJECT_SIZE][IMAGE_POINT_SIZE];
double Point_Buffer_y[IMAGE_OBJECT_SIZE][IMAGE_POINT_SIZE];

//---------------------------------------------------------------------------------------
void DRAW_Text( HDC hDC , HPALETTE hPal , int x , int y , int size , char *str  , int tcolor) {
	HFONT   hOldFont;
	HFONT   hNewFont;
	RECT	wRect;
	int		len = lstrlen(str);

	SelectPalette ( hDC , hPal , 1 );
	RealizePalette ( hDC );
	SetBkMode( hDC , TRANSPARENT );

	//SetTextColor( hDC , RGB( 0 , 0 , 0 ) );
    SetTextColor( hDC , PALETTEINDEX(tcolor));

	hNewFont = CreateFont( size , 0 , 0 , 0 , FW_BOLD , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , "Arial" );
	hOldFont = SelectObject( hDC , hNewFont );

	wRect.left   = x;
	wRect.top    = y;
	wRect.right  = x + ( (size/2) * len ) + 1;
	wRect.bottom = y + size;

	DrawTextEx( hDC , str , -1 , &wRect , DT_CENTER | DT_VCENTER | DT_SINGLELINE | DT_NOPREFIX , NULL );

	SelectObject( hDC, hOldFont );
	DeleteObject( hNewFont ) ;
}

//---------------------------------------------------------------------------------------
void DRAW_Line( HDC hDC , HPALETTE hPal , int x1 , int y1 , int x2 , int y2 , int lcolor ) {
	HPEN	hOldBrush;
	HPEN	hNewBrush;

	SelectPalette ( hDC , hPal , 1 );
	RealizePalette ( hDC );
	
	hNewBrush = CreatePen( PS_SOLID , 1 , PALETTEINDEX( lcolor ) );
	hOldBrush = SelectObject( hDC , hNewBrush );
	MoveToEx( hDC , x1 , y1 , NULL );
	LineTo( hDC , x2 , y2 );
	hNewBrush = SelectObject( hDC , hOldBrush );
	DeleteObject( hNewBrush );
}

//---------------------------------------------------------------------------------------
void DRAW_PolyGon( HDC hDC , HPALETTE hPal , POINT *PointArray , int len , int b , int l ) {
	HPEN	hOldBrush1;
	HPEN	hNewBrush1;
	HPEN	hOldBrush2;
	HPEN	hNewBrush2;

	SelectPalette ( hDC , hPal , 1 );
	RealizePalette ( hDC );
	if (b >= 0 && l >= 0) {
		hNewBrush1 = (HPEN)CreateSolidBrush( PALETTEINDEX( b ) );
		hOldBrush1 = SelectObject( hDC , hNewBrush1 );
		hNewBrush2 = CreatePen( PS_SOLID , 1 , PALETTEINDEX( l ) );
		hOldBrush2 = SelectObject( hDC , hNewBrush2 );
		Polygon( hDC , PointArray , len );
		hNewBrush1 = SelectObject( hDC , hOldBrush1 );
		hNewBrush2 = SelectObject( hDC , hOldBrush2 );
		DeleteObject( hNewBrush1 );
		DeleteObject( hNewBrush2 );
	} else if (b >= 0) {
		hNewBrush1 = (HPEN)CreateSolidBrush( PALETTEINDEX( b ) );
		hOldBrush1 = SelectObject( hDC , hNewBrush1 );
		Polygon( hDC , PointArray , len );
		hNewBrush1 = SelectObject( hDC , hOldBrush1 );
		DeleteObject( hNewBrush1 );
	} else if (l >= 0) {
		hNewBrush2 = CreatePen( PS_SOLID , 1 , PALETTEINDEX( l ) );
		hOldBrush2 = SelectObject( hDC , hNewBrush2 );
		Polyline( hDC , PointArray , len );
		hNewBrush2 = SelectObject( hDC , hOldBrush2 );
		DeleteObject( hNewBrush2 );
	}
}

//---------------------------------------------------------------------------------------
void DRAW_Circle( HDC hDC , HPALETTE hPal , int left , int top , int right , int bottom , int b , int l ) {
	HPEN	hOldBrush1;
	HPEN	hNewBrush1;
	HPEN	hOldBrush2;
	HPEN	hNewBrush2;

	SelectPalette ( hDC , hPal , 1 );
	RealizePalette ( hDC );

	hNewBrush1 = (HPEN)CreateSolidBrush( PALETTEINDEX( b ) );
	hOldBrush1 = SelectObject( hDC , hNewBrush1 );
	hNewBrush2 = CreatePen( PS_SOLID , 1 , PALETTEINDEX( l ) );
	hOldBrush2 = SelectObject( hDC , hNewBrush2 );
	
	Ellipse( hDC , left , top , right , bottom );

	hNewBrush1 = SelectObject( hDC , hOldBrush1 );
	hNewBrush2 = SelectObject( hDC , hOldBrush2 );
	DeleteObject( hNewBrush1 );
	DeleteObject( hNewBrush2 );
}

//----------------------------------------------------------------------------------
void IMAGE_DRAWING( HDC hDC , HPALETTE , int i , int m , int c1 , int c2 , double d , int xs , int ys , int l );

//----------------------------------------------------------------------------------
__declspec(dllexport) void IMAGE_LIBRARY_PALETTE( HDC hDC , HPALETTE hPal , int x , int y , int FingerA_Status , int FingerB_Status , int FingerA_Source , int FingerB_Source , int FingerA_Use , int FingerB_Use , double rotate_value , double extend_value , double Wafer_Mask_Mode , double zoom , char *s , char *sp1 , char *sp2 , char *sp3 ) {
	POINT	PointArray[IMAGE_POINT_SIZE];
	char Buffer[64];
	int Wafer_Size , Finger_Use_Mode , Finger_Move , Show_Finger , Draw_Mode , Finger_Move_Size , WaferMask;
	int j , k;
	double DOUBLE_INTERVAL;
	double zoom2;
	double Temp; //200708.30

	//---------------------------------------------------------------
	// Index Map
	//===============================================================
	// i  - Wafer_A_Status
	// i1 - Wafer_B_Status
	// i2 - Wafer_A_Source (-1:Hide Source A String)
	// i3 - Wafer_B_Source (-1:Hide Source B String)
	// i4 - FingerA_Use / Wafer_A_Result
	// i5 - FingerB_Use / Wafer_B_Result
	//---------------------------------------------------------------
	// d  - rotate_value
	// d1 - extend_value
	// d2 - Wafer_Mask_Mode  XXXXXX
	//                       TTTTTT
	//                       |||||+-> 0:Wafer(Circle) , 1:Mask(Rectangle)
	//                       ||||+--> When FingerMove , Finger Move Size
	//                       |||+---> 0:FingerNotMove , 1:FingerMove/Left , 2:FingerMove/Right
	//                       ||+----> 0:ShowUnderArm  , 1:HideUnderArm
	//                       |+-----> 0:ShowFingerSide , 1:HideFingerSide
	//                       +------> 0:FingerUsewithIO(i4,i5) 1:FingerASide&Result(i4,i5) 2:FingerBSide&Result(i4,i5) 3:FingerABSide&Result(i4,i5)
	// d3 - zoom
	//---------------------------------------------------------------
	// s  - N/A
	// s1 - N/A
	// s2 - N/A
	// s3 - N/A
	//---------------------------------------------------------------

	if ( zoom <= 1 ) zoom = 1;

	Wafer_Size			= ( ( (int)Wafer_Mask_Mode )/1000000 ) %100;
	Finger_Use_Mode		= ( ( (int)Wafer_Mask_Mode )/100000 ) %10;
	Show_Finger			= ( ( (int)Wafer_Mask_Mode )/10000 ) %10;
	Draw_Mode   		= ( ( (int)Wafer_Mask_Mode )/1000 ) %10; //mgsong add
	Finger_Move			= ( ( (int)Wafer_Mask_Mode )/100 ) %10;
	Finger_Move_Size	= ( ( (int)Wafer_Mask_Mode )/10 ) %10;
	WaferMask			= ( ( (int)Wafer_Mask_Mode )/1 ) %10;

	switch (WaferMask) {
	case 2 :
		IMAGE_TABLE[84].Pointer = 25;
		IMAGE_TABLE[91].Pointer = 26;
 		WaferMask = 1;
		break;
	case 3 :
		IMAGE_TABLE[84].Pointer = 27;
		IMAGE_TABLE[91].Pointer = 28;
		WaferMask = 1;
		break;
	case 4 :
		IMAGE_TABLE[84].Pointer = 29;
		IMAGE_TABLE[91].Pointer = 30;
		WaferMask = 1;
		break;
	case 5 :
		IMAGE_TABLE[84].Pointer = 31;
		IMAGE_TABLE[91].Pointer = 32;
		WaferMask = 1;
		break;
	}

	if ( Finger_Use_Mode != 0 ) {
		switch (FingerA_Use) {
		case 1 :
			IMAGE_CIRCLE_TABLE[17].fcolor  = 114;
			IMAGE_POLYGON_TABLE[17].fcolor = 117;
			IMAGE_POLYGON_TABLE[18].fcolor = 116;
			IMAGE_POLYGON_TABLE[19].fcolor = 114;
			IMAGE_CIRCLE_TABLE[53].fcolor  = 114;
			IMAGE_CIRCLE_TABLE[17].ecolor  = 120;
			IMAGE_POLYGON_TABLE[17].ecolor = 117;
			IMAGE_POLYGON_TABLE[18].ecolor = 116;
			IMAGE_POLYGON_TABLE[19].ecolor = 114;
			IMAGE_CIRCLE_TABLE[53].ecolor  = 118;
			break;
		case 2 :
			IMAGE_CIRCLE_TABLE[17].fcolor  = 74;
			IMAGE_POLYGON_TABLE[17].fcolor = 77;
			IMAGE_POLYGON_TABLE[18].fcolor = 76;
			IMAGE_POLYGON_TABLE[19].fcolor = 74;
			IMAGE_CIRCLE_TABLE[53].fcolor  = 74;
			IMAGE_CIRCLE_TABLE[17].ecolor  = 80;
			IMAGE_POLYGON_TABLE[17].ecolor = 77;
			IMAGE_POLYGON_TABLE[18].ecolor = 76;
			IMAGE_POLYGON_TABLE[19].ecolor = 74;
			IMAGE_CIRCLE_TABLE[53].ecolor  = 78;
			break;
		default :
			IMAGE_CIRCLE_TABLE[17].fcolor  = 104;
			IMAGE_POLYGON_TABLE[17].fcolor = 107;
			IMAGE_POLYGON_TABLE[18].fcolor = 107;
			IMAGE_POLYGON_TABLE[19].fcolor = 107;
			IMAGE_CIRCLE_TABLE[53].fcolor  = 104;
			IMAGE_CIRCLE_TABLE[17].ecolor  = 110;
			IMAGE_POLYGON_TABLE[17].ecolor = 107;
			IMAGE_POLYGON_TABLE[18].ecolor = 106;
			IMAGE_POLYGON_TABLE[19].ecolor = 104;
			IMAGE_CIRCLE_TABLE[53].ecolor = 108;
			break;
		}
				
		switch (FingerB_Use) {
		case 1 :
			IMAGE_CIRCLE_TABLE[18].fcolor  = 114;
			IMAGE_POLYGON_TABLE[20].fcolor = 117;
			IMAGE_POLYGON_TABLE[21].fcolor = 116;
			IMAGE_POLYGON_TABLE[22].fcolor = 114;
			IMAGE_CIRCLE_TABLE[54].fcolor  = 114;
			IMAGE_CIRCLE_TABLE[18].ecolor  = 120;
			IMAGE_POLYGON_TABLE[20].ecolor = 117;
			IMAGE_POLYGON_TABLE[21].ecolor = 116;
			IMAGE_POLYGON_TABLE[22].ecolor = 114;
			IMAGE_CIRCLE_TABLE[54].ecolor  = 118;
			break;
		case 2 :
			IMAGE_CIRCLE_TABLE[18].fcolor  = 74;
			IMAGE_POLYGON_TABLE[20].fcolor = 77;
			IMAGE_POLYGON_TABLE[21].fcolor = 76;
			IMAGE_POLYGON_TABLE[22].fcolor = 74;
			IMAGE_CIRCLE_TABLE[54].fcolor  = 74;
			IMAGE_CIRCLE_TABLE[18].ecolor  = 80;
			IMAGE_POLYGON_TABLE[20].ecolor = 77;
			IMAGE_POLYGON_TABLE[21].ecolor = 76;
			IMAGE_POLYGON_TABLE[22].ecolor = 74;
			IMAGE_CIRCLE_TABLE[54].ecolor  = 78;
			break;
		default :
			IMAGE_CIRCLE_TABLE[18].fcolor  = 104;
			IMAGE_POLYGON_TABLE[20].fcolor = 107;
			IMAGE_POLYGON_TABLE[21].fcolor = 106;
			IMAGE_POLYGON_TABLE[22].fcolor = 104;
			IMAGE_CIRCLE_TABLE[54].fcolor = 104;
			IMAGE_CIRCLE_TABLE[18].ecolor  = 110;
			IMAGE_POLYGON_TABLE[20].ecolor = 107;
			IMAGE_POLYGON_TABLE[21].ecolor = 106;
			IMAGE_POLYGON_TABLE[22].ecolor = 104;
			IMAGE_CIRCLE_TABLE[54].ecolor = 108;
			break;
		}
	}
	
	zoom2 = zoom + (double) (Wafer_Size / 10);
	for (j =  0 ; j < IMAGE_OBJECT_SIZE ; j++) IMAGE_TABLE[j].Use = TRUE;

	//20070125 mgsong add
	for (j = 83; j <= 96 ; j++) {
		if (j == 83 || j == 90 || j == 88 || j == 89 || j == 95 || j == 96) continue;
		else IMAGE_TABLE[j].Use = FALSE;
	}
	
	switch (Draw_Mode) {
	case 0:
		//Draw all
		
		break;
	case 1:
		//Arm A Fork 2 Wafer Only
		for (j = 0  ; j < 17 ; j++) IMAGE_TABLE[j].Use = FALSE;
		for (j = 29 ; j < 36 ; j++) IMAGE_TABLE[j].Use = FALSE;
		for (j = 43 ; j < 83 ; j++) IMAGE_TABLE[j].Use = FALSE;
		break;
	case 2:
		//Arm B Fork 2 Wafer Only
		for (j = 0 ; j < 83 ; j++) IMAGE_TABLE[j].Use = FALSE;
		break;
	case 3:	
		break;
	case 4:	
		break;
	}

		
	for (j = 83 ; j <= 89 ; j++) { if (FingerA_Status == 0) IMAGE_TABLE[j].Use = FALSE; }
	for (j = 90 ; j <= 96 ; j++) { if (FingerB_Status == 0) IMAGE_TABLE[j].Use = FALSE; }
	
	if ( WaferMask == 1 ) IMAGE_TABLE[83].Use = IMAGE_TABLE[90].Use = FALSE;
	else                  IMAGE_TABLE[84].Use = IMAGE_TABLE[91].Use = FALSE;
	
	if ( Finger_Move == 0 ) {
		IMAGE_TABLE[83].Use = FALSE;
		IMAGE_TABLE[84].Use = FALSE;
		IMAGE_TABLE[85].Use = FALSE;
	}
	
	if (FingerA_Source < 0) IMAGE_TABLE[88].Use = FALSE;
	if (FingerB_Source < 0) IMAGE_TABLE[95].Use = FALSE;

	//  Zoom Control
	for (j = 0 ; j < IMAGE_OBJECT_SIZE ; j++) {
		if (!IMAGE_TABLE[j].Use) continue;
		if ((j >= 83 ) && (j <= 96)) {
			switch (IMAGE_TABLE[j].Type) {
				case DRAW_LINE :
					Point_Buffer_x[j][0] = IMAGE_LINE_TABLE[IMAGE_TABLE[j].Pointer].Point_X1 * zoom2;
					Point_Buffer_y[j][0] = IMAGE_LINE_TABLE[IMAGE_TABLE[j].Pointer].Point_Y1 * -zoom2;
					Point_Buffer_x[j][1] = IMAGE_LINE_TABLE[IMAGE_TABLE[j].Pointer].Point_X2 * zoom2;
					Point_Buffer_y[j][1] = IMAGE_LINE_TABLE[IMAGE_TABLE[j].Pointer].Point_Y2 * -zoom2;
					break;
				case DRAW_CIRCLE :
					Point_Buffer_x[j][0] = IMAGE_CIRCLE_TABLE[IMAGE_TABLE[j].Pointer].Point_X * zoom2;
					Point_Buffer_y[j][0] = IMAGE_CIRCLE_TABLE[IMAGE_TABLE[j].Pointer].Point_Y * -zoom2;
					Point_Buffer_x[j][1] = IMAGE_CIRCLE_TABLE[IMAGE_TABLE[j].Pointer].Point_XS * zoom2;
					Point_Buffer_y[j][1] = IMAGE_CIRCLE_TABLE[IMAGE_TABLE[j].Pointer].Point_YS * -zoom2;
					break;
				case DRAW_POLYGON :
					for (k = 0 ; k < IMAGE_POLYGON_TABLE[IMAGE_TABLE[j].Pointer].len ; k++) {
						Point_Buffer_x[j][k] = IMAGE_POLYGON_TABLE[IMAGE_TABLE[j].Pointer].Point_X[k] * zoom2;
						Point_Buffer_y[j][k] = IMAGE_POLYGON_TABLE[IMAGE_TABLE[j].Pointer].Point_Y[k] * -zoom2;
					}
					break;
				case DRAW_TEXT :
					Point_Buffer_x[j][0] = IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].Point_X * zoom2;
					Point_Buffer_y[j][0] = IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].Point_Y * -zoom2;
					Point_Buffer_x[j][1] = IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].Point_XS * zoom2;
					Point_Buffer_y[j][1] = IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].Point_YS * -zoom2;
					break;
			}
		} else {
			switch (IMAGE_TABLE[j].Type) {
				case DRAW_LINE :
					Point_Buffer_x[j][0] = IMAGE_LINE_TABLE[IMAGE_TABLE[j].Pointer].Point_X1 * zoom;
					Point_Buffer_y[j][0] = IMAGE_LINE_TABLE[IMAGE_TABLE[j].Pointer].Point_Y1 * -zoom;
					Point_Buffer_x[j][1] = IMAGE_LINE_TABLE[IMAGE_TABLE[j].Pointer].Point_X2 * zoom;
					Point_Buffer_y[j][1] = IMAGE_LINE_TABLE[IMAGE_TABLE[j].Pointer].Point_Y2 * -zoom;
					break;
				case DRAW_CIRCLE :
					Point_Buffer_x[j][0] = IMAGE_CIRCLE_TABLE[IMAGE_TABLE[j].Pointer].Point_X * zoom;
					Point_Buffer_y[j][0] = IMAGE_CIRCLE_TABLE[IMAGE_TABLE[j].Pointer].Point_Y * -zoom;
					Point_Buffer_x[j][1] = IMAGE_CIRCLE_TABLE[IMAGE_TABLE[j].Pointer].Point_XS * zoom;
					Point_Buffer_y[j][1] = IMAGE_CIRCLE_TABLE[IMAGE_TABLE[j].Pointer].Point_YS * -zoom;
					break;
				case DRAW_POLYGON :
					for (k = 0 ; k < IMAGE_POLYGON_TABLE[IMAGE_TABLE[j].Pointer].len ; k++) {
						Point_Buffer_x[j][k] = IMAGE_POLYGON_TABLE[IMAGE_TABLE[j].Pointer].Point_X[k] * zoom;
						Point_Buffer_y[j][k] = IMAGE_POLYGON_TABLE[IMAGE_TABLE[j].Pointer].Point_Y[k] * -zoom;
					}
					break;
				case DRAW_TEXT :
					Point_Buffer_x[j][0] = IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].Point_X * zoom;
					Point_Buffer_y[j][0] = IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].Point_Y * -zoom;
					Point_Buffer_x[j][1] = IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].Point_XS * zoom;
					Point_Buffer_y[j][1] = IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].Point_YS * -zoom;
					break;
			}
		}
	}

	//
	if ((Finger_Move == 1) || (Finger_Move == 2)) {
		if      (Finger_Move == 1) DOUBLE_INTERVAL = -zoom * Finger_Move_Size;
		else if (Finger_Move == 2) DOUBLE_INTERVAL =  zoom * Finger_Move_Size;
		for (j = 83 ; j <= 96 ; j++) {
			if (!IMAGE_TABLE[j].Use ) continue;
			switch (IMAGE_TABLE[j].Type) {
				case DRAW_LINE :
					Point_Buffer_x[j][0] += DOUBLE_INTERVAL;
					Point_Buffer_x[j][1] += DOUBLE_INTERVAL;
					break;
				case DRAW_CIRCLE :
					Point_Buffer_x[j][0] += DOUBLE_INTERVAL;
					break;
				case DRAW_POLYGON :
					for (k = 0 ; k < IMAGE_POLYGON_TABLE[IMAGE_TABLE[j].Pointer].len ; k++) {
						Point_Buffer_x[j][k] += DOUBLE_INTERVAL;
					}
					break;
				case DRAW_TEXT :
					Point_Buffer_x[j][0] += DOUBLE_INTERVAL;
					break;
			}
		}
	}

	//Ankle Arm Rotate Only
	for (j = 11 ; j <= 96; j++) {
		if (!IMAGE_TABLE[j].Use) continue;
		if (j >= 17 && j <= 22)	 continue; //mgsong	
		if (j >= 29 && j <= 42)  continue; //mgsong
		if (j >= 45 && j <= 50)  continue; //mgsong
		if (j >= 57 && j <= 62)  continue; //mgsong
		//if (j >= 69 && j <= 82)  continue; //mgsong
		if (j >= 69 && j <= 96)  continue; //mgsong
		if (j == 43 || j == 44)  continue; //mgsong
		switch ( IMAGE_TABLE[j].Type ) {
			case DRAW_LINE :
				if (extend_value > 0) {
					//Animate Arm Check
					if (j >= 45 && j <= 82) continue;
					if (j >= 90 && j <= 96) continue;

					//Hand A Use Case
					if (j >= 23 && j <= 28) {
						rotate( Point_Buffer_x[j][0] , Point_Buffer_y[j][0] , 10.16*zoom  , 1.5*zoom , extend_value*(2)  , &Point_Buffer_x[j][0] , &Point_Buffer_y[j][0] );
						rotate( Point_Buffer_x[j][1] , Point_Buffer_y[j][1] , 10.16*zoom  , 1.5*zoom , extend_value*(2)  , &Point_Buffer_x[j][1] , &Point_Buffer_y[j][1] );
					} else {
						rotate( Point_Buffer_x[j][0] , Point_Buffer_y[j][0] , -10.16*zoom , 1.5*zoom , extend_value*(-2) , &Point_Buffer_x[j][0] , &Point_Buffer_y[j][0] );
						rotate( Point_Buffer_x[j][1] , Point_Buffer_y[j][1] , -10.16*zoom , 1.5*zoom , extend_value*(-2) , &Point_Buffer_x[j][1] , &Point_Buffer_y[j][1] );	
					}
				} else if (extend_value < 0) {
					//Animate Arm Check
					if (j >= 5  && j <= 44) continue;
					if (j >= 83 && j <= 89) continue;

					//Hand B Use Case
					//2007.08.30
					Temp = extend_value * (-1);
					if (j >= 63 && j <= 68) {
						rotate( Point_Buffer_x[j][0] , Point_Buffer_y[j][0] , 10.16*zoom  , 3*zoom , Temp*(2)  , &Point_Buffer_x[j][0] , &Point_Buffer_y[j][0] );
						rotate( Point_Buffer_x[j][1] , Point_Buffer_y[j][1] , 10.16*zoom  , 3*zoom , Temp*(2)  , &Point_Buffer_x[j][1] , &Point_Buffer_y[j][1] );
					} else {
						rotate( Point_Buffer_x[j][0] , Point_Buffer_y[j][0] , -10.16*zoom , 3*zoom , Temp*(-2) , &Point_Buffer_x[j][0] , &Point_Buffer_y[j][0] );
						rotate( Point_Buffer_x[j][1] , Point_Buffer_y[j][1] , -10.16*zoom , 3*zoom , Temp*(-2) , &Point_Buffer_x[j][1] , &Point_Buffer_y[j][1] );	
					}
				} else {
				}
				
				break;
			case DRAW_CIRCLE :
				if (extend_value > 0) {
					//Animate Arm Check
					if (j >= 45 && j <= 82) continue;
					if (j >= 90 && j <= 96) continue;

					//Hand A Use Case
					if (j >= 23 && j <= 28) {
						rotate( Point_Buffer_x[j][0] , Point_Buffer_y[j][0] , 10.16*zoom  , 1.5*zoom , extend_value*(2) , &Point_Buffer_x[j][0] , &Point_Buffer_y[j][0] );
					} else {
						rotate( Point_Buffer_x[j][0] , Point_Buffer_y[j][0] , -10.16*zoom , 1.5*zoom , extend_value*(-2) , &Point_Buffer_x[j][0] , &Point_Buffer_y[j][0] );
					}
				} else if (extend_value < 0) {
					//Animate Arm Check
					if (j >= 5  && j <= 44) continue;
					if (j >= 83 && j <= 89) continue;

					//Hand B Use Case
					//2007.08.30
					Temp = extend_value * (-1);
					if (j >= 63 && j <= 68) {
						rotate( Point_Buffer_x[j][0] , Point_Buffer_y[j][0] , 10.16*zoom  , 3*zoom , Temp*(2) , &Point_Buffer_x[j][0] , &Point_Buffer_y[j][0] );
					} else {
						rotate( Point_Buffer_x[j][0] , Point_Buffer_y[j][0] , -10.16*zoom , 3*zoom , Temp*(-2) , &Point_Buffer_x[j][0] , &Point_Buffer_y[j][0] );
					}
				} else {
				}
				break;
			case DRAW_POLYGON :
				if (extend_value > 0) {
					//Animate Arm Check
					if (j >= 45 && j <= 82) continue;
					if (j >= 90 && j <= 96) continue;

					//Hand A Use Case
					if (j >= 23 && j <= 28) {
						for ( k = 0 ; k < IMAGE_POLYGON_TABLE[IMAGE_TABLE[j].Pointer].len ; k++ ) {
							rotate( Point_Buffer_x[j][k] , Point_Buffer_y[j][k] , 10.16*zoom , 1.5*zoom , extend_value*(2) , &Point_Buffer_x[j][k] , &Point_Buffer_y[j][k] );
						}
					} else {
						for ( k = 0 ; k < IMAGE_POLYGON_TABLE[IMAGE_TABLE[j].Pointer].len ; k++ ) {
							rotate( Point_Buffer_x[j][k] , Point_Buffer_y[j][k] , -10.16*zoom , 1.5*zoom , extend_value*(-2) , &Point_Buffer_x[j][k] , &Point_Buffer_y[j][k] );
						}
					}
				} else if (extend_value < 0) {
					//Animate Arm Check
					if (j >= 5  && j <= 44) continue;
					if (j >= 83 && j <= 89) continue;

					//Hand B Use Case
					//2007.08.30
					Temp = extend_value * (-1);
					if (j >= 63 && j <= 68) {
						for ( k = 0 ; k < IMAGE_POLYGON_TABLE[IMAGE_TABLE[j].Pointer].len ; k++ ) {
							rotate( Point_Buffer_x[j][k] , Point_Buffer_y[j][k] , 10.16*zoom , 3*zoom , Temp*(2) , &Point_Buffer_x[j][k] , &Point_Buffer_y[j][k] );
						}
					} else {
						for ( k = 0 ; k < IMAGE_POLYGON_TABLE[IMAGE_TABLE[j].Pointer].len ; k++ ) {
							rotate( Point_Buffer_x[j][k] , Point_Buffer_y[j][k] , -10.16*zoom , 3*zoom , Temp*(-2) , &Point_Buffer_x[j][k] , &Point_Buffer_y[j][k] );
						}
					}
				} else {
				}
				break;
			case DRAW_TEXT :
				if (extend_value > 0) {
					//Animate Arm Check
					if (j >= 45 && j <= 82) continue;
					if (j >= 90 && j <= 96) continue;

					//Hand A Use Case
					if (j >= 23 && j <= 28) {
						rotate( Point_Buffer_x[j][0] , Point_Buffer_y[j][0] , -10.16*zoom , 1.5*zoom , extend_value*(2)  , &Point_Buffer_x[j][0] , &Point_Buffer_y[j][0] );
					} else {
						rotate( Point_Buffer_x[j][0] , Point_Buffer_y[j][0] , -10.16*zoom , 1.5*zoom , extend_value*(-2) , &Point_Buffer_x[j][0] , &Point_Buffer_y[j][0] );
					}
				} else if (extend_value < 0) {
					//Animate Arm Check
					if (j >= 5  && j <= 44) continue;
					if (j >= 83 && j <= 89) continue;

					//Hand B Use Case
					//2007.08.30
					Temp = extend_value * (-1);
					if (j >= 63 && j <= 68) {
						rotate( Point_Buffer_x[j][0] , Point_Buffer_y[j][0] , -10.16*zoom , 3*zoom , Temp*(2)  , &Point_Buffer_x[j][0] , &Point_Buffer_y[j][0] );
					} else {
						rotate( Point_Buffer_x[j][0] , Point_Buffer_y[j][0] , -10.16*zoom , 3*zoom , Temp*(-2) , &Point_Buffer_x[j][0] , &Point_Buffer_y[j][0] );
					}
				} else {
				}
				break;
		}
	}

	//Total Arm Rotate
	for ( j = 5 ; j <= 96 ; j++ ) {
		if (j == 43 || j == 44)    continue;
		if ( !IMAGE_TABLE[j].Use ) continue;
		switch ( IMAGE_TABLE[j].Type ) {
			case DRAW_LINE :
				if (extend_value > 0) {
					//Animate Arm Check
					if (j >= 45 && j <= 82) continue;
					if (j >= 90 && j <= 96) continue;

					//Hand A Use Case
					if (j >= 17 && j <= 28) {
						//2007.08.30
						if (j >= 17 && j <= 22) {
							rotate( Point_Buffer_x[j][0] , Point_Buffer_y[j][0] , 0 , 2*zoom , extend_value*(-1) , &Point_Buffer_x[j][0] , &Point_Buffer_y[j][0] );
							rotate( Point_Buffer_x[j][1] , Point_Buffer_y[j][1] , 0 , 2*zoom , extend_value*(-1) , &Point_Buffer_x[j][1] , &Point_Buffer_y[j][1] );
						} else {
							rotate( Point_Buffer_x[j][0] , Point_Buffer_y[j][0] , 0 , 4*zoom , extend_value*(-0.7) , &Point_Buffer_x[j][0] , &Point_Buffer_y[j][0] );
							rotate( Point_Buffer_x[j][1] , Point_Buffer_y[j][1] , 0 , 4*zoom , extend_value*(-0.7) , &Point_Buffer_x[j][1] , &Point_Buffer_y[j][1] );
						}
					} else if ((j >= 29 && j <= 42) || (j >= 83 && j <= 89)) {
						//rotate( Point_Buffer_x[j][0] , Point_Buffer_y[j][0] , 0 , extend_value , 0 , &Point_Buffer_x[j][0] , &Point_Buffer_y[j][0] );
						//rotate( Point_Buffer_x[j][1] , Point_Buffer_y[j][1] , 0 , extend_value , 0 , &Point_Buffer_x[j][1] , &Point_Buffer_y[j][1] );	
						//mgsong
						Point_Buffer_y[j][0] += extend_value*1.4;
						Point_Buffer_y[j][1] += extend_value*1.4;

					} else {
						//2007.08.30
						if (j >= 5 && j <= 10) {
							rotate( Point_Buffer_x[j][0] , Point_Buffer_y[j][0] , 0 , 2*zoom , extend_value*1 , &Point_Buffer_x[j][0] , &Point_Buffer_y[j][0] );
							rotate( Point_Buffer_x[j][1] , Point_Buffer_y[j][1] , 0 , 2*zoom , extend_value*1 , &Point_Buffer_x[j][1] , &Point_Buffer_y[j][1] );
						} else {
							rotate( Point_Buffer_x[j][0] , Point_Buffer_y[j][0] , 0 , 4*zoom , extend_value*0.7 , &Point_Buffer_x[j][0] , &Point_Buffer_y[j][0] );
							rotate( Point_Buffer_x[j][1] , Point_Buffer_y[j][1] , 0 , 4*zoom , extend_value*0.7 , &Point_Buffer_x[j][1] , &Point_Buffer_y[j][1] );
						}
					}
				} else if (extend_value < 0) {
					//Animate Arm Check
					if (j >= 5  && j <= 44) continue;
					if (j >= 83 && j <= 89) continue;
					
					//Hand B Use Case
					//2007.08.30
					Temp = extend_value * (-1);
					if (j >= 57 && j <= 68) {
						rotate( Point_Buffer_x[j][0] , Point_Buffer_y[j][0] , 0 , 3*zoom , Temp*(-0.7) , &Point_Buffer_x[j][0] , &Point_Buffer_y[j][0] );
						rotate( Point_Buffer_x[j][1] , Point_Buffer_y[j][1] , 0 , 3*zoom , Temp*(-0.7) , &Point_Buffer_x[j][1] , &Point_Buffer_y[j][1] );
					} else if ((j >= 69 && j <= 82) || (j >= 90 && j <= 96)) {
						//rotate( Point_Buffer_x[j][0] , Point_Buffer_y[j][0] , 0 , extend_value , 0 , &Point_Buffer_x[j][0] , &Point_Buffer_y[j][0] );
						//rotate( Point_Buffer_x[j][1] , Point_Buffer_y[j][1] , 0 , extend_value , 0 , &Point_Buffer_x[j][1] , &Point_Buffer_y[j][1] );	
						//mgsong
						Point_Buffer_y[j][0] += Temp*1.4;
						Point_Buffer_y[j][1] += Temp*1.4;

					} else {
						rotate( Point_Buffer_x[j][0] , Point_Buffer_y[j][0] , 0 , 3*zoom , Temp*0.7 , &Point_Buffer_x[j][0] , &Point_Buffer_y[j][0] );
						rotate( Point_Buffer_x[j][1] , Point_Buffer_y[j][1] , 0 , 3*zoom , Temp*0.7 , &Point_Buffer_x[j][1] , &Point_Buffer_y[j][1] );
					}
				} else {
				}
				break;
			case DRAW_CIRCLE :
				if (extend_value > 0) {
					//Animate Arm Check
					if (j >= 45 && j <= 82) continue;
					if (j >= 90 && j <= 96) continue;

					//Hand A Use Case
					if (j >= 17 && j <= 28) {
						//2007.08.30
						if (j >= 17 && j <= 22) 
							rotate( Point_Buffer_x[j][0] , Point_Buffer_y[j][0] , 0 , 2*zoom , extend_value*(-1) , &Point_Buffer_x[j][0] , &Point_Buffer_y[j][0] );
						else
							rotate( Point_Buffer_x[j][0] , Point_Buffer_y[j][0] , 0 , 4*zoom , extend_value*(-0.7) , &Point_Buffer_x[j][0] , &Point_Buffer_y[j][0] );
					} else if ((j >= 29 && j <= 42) || (j >= 83 && j <= 89)) {
						//rotate( Point_Buffer_x[j][0] , Point_Buffer_y[j][0] , 0 , extend_value , 0 , &Point_Buffer_x[j][0] , &Point_Buffer_y[j][0] );	
						//mgsong
						Point_Buffer_y[j][0] += extend_value*1.4;
					} else {
						//2007.08.30
						if (j >= 5 && j <= 10) 
							rotate( Point_Buffer_x[j][0] , Point_Buffer_y[j][0] , 0 , 2*zoom , extend_value*1 , &Point_Buffer_x[j][0] , &Point_Buffer_y[j][0] );
						else
							rotate( Point_Buffer_x[j][0] , Point_Buffer_y[j][0] , 0 , 4*zoom , extend_value*0.7 , &Point_Buffer_x[j][0] , &Point_Buffer_y[j][0] );
					}
				} else if (extend_value < 0) {
					//Animate Arm Check
					if (j >= 5  && j <= 44) continue;
					if (j >= 83 && j <= 89) continue;

					//Hand B Use Case
					Temp = extend_value * (-1);
					if (j >= 57 && j <= 68) {
						rotate( Point_Buffer_x[j][0] , Point_Buffer_y[j][0] , 0 , 3*zoom , Temp*(-0.7) , &Point_Buffer_x[j][0] , &Point_Buffer_y[j][0] );
					} else if ((j >= 69 && j <= 82) || (j >= 90 && j <= 96)) {
						//rotate( Point_Buffer_x[j][0] , Point_Buffer_y[j][0] , 0 , extend_value , 0 , &Point_Buffer_x[j][0] , &Point_Buffer_y[j][0] );	
						//mgsong
						Point_Buffer_y[j][0] += Temp*1.4;
					} else {
						rotate( Point_Buffer_x[j][0] , Point_Buffer_y[j][0] , 0 , 3*zoom , Temp*0.7 , &Point_Buffer_x[j][0] , &Point_Buffer_y[j][0] );
					}
				} else {
				}
				break;
			case DRAW_POLYGON :
				if (extend_value > 0) {
					//Animate Arm Check
					if (j >= 45 && j <= 82) continue;
					if (j >= 90 && j <= 96) continue;

					//Hand A Use Case
					if (j >= 17 && j <= 28) {
						//2007.08.30
						if (j >= 17 && j <= 22)  {
							for ( k = 0 ; k < IMAGE_POLYGON_TABLE[IMAGE_TABLE[j].Pointer].len ; k++ ) {
								rotate( Point_Buffer_x[j][k] , Point_Buffer_y[j][k] , 0 , 2*zoom , extend_value*(-1) , &Point_Buffer_x[j][k] , &Point_Buffer_y[j][k] );
							}
						} else {
							for ( k = 0 ; k < IMAGE_POLYGON_TABLE[IMAGE_TABLE[j].Pointer].len ; k++ ) {
								rotate( Point_Buffer_x[j][k] , Point_Buffer_y[j][k] , 0 , 4*zoom , extend_value*(-0.7) , &Point_Buffer_x[j][k] , &Point_Buffer_y[j][k] );
							}
						}
					} else if ((j >= 29 && j <= 42) || (j >= 83 && j <= 89)) {
						for ( k = 0 ; k < IMAGE_POLYGON_TABLE[IMAGE_TABLE[j].Pointer].len ; k++ ) {
							//rotate( Point_Buffer_x[j][k] , Point_Buffer_y[j][k] , 0 , extend_value , 0 , &Point_Buffer_x[j][k] , &Point_Buffer_y[j][k] );
							//mgsong
							Point_Buffer_y[j][k] += extend_value*1.4;
						}
					} else {
						//2007.08.30
						if (j >= 5 && j <= 10) {
							for ( k = 0 ; k < IMAGE_POLYGON_TABLE[IMAGE_TABLE[j].Pointer].len ; k++ ) {
								rotate( Point_Buffer_x[j][k] , Point_Buffer_y[j][k] , 0 , 2*zoom , extend_value*1 , &Point_Buffer_x[j][k] , &Point_Buffer_y[j][k] );
							}
						} else {
							for ( k = 0 ; k < IMAGE_POLYGON_TABLE[IMAGE_TABLE[j].Pointer].len ; k++ ) {
								rotate( Point_Buffer_x[j][k] , Point_Buffer_y[j][k] , 0 , 4*zoom , extend_value*0.7 , &Point_Buffer_x[j][k] , &Point_Buffer_y[j][k] );
							}
						}
					}
				} else if (extend_value < 0) {
					//Animate Arm Check
					if (j >= 5  && j <= 44) continue;
					if (j >= 83 && j <= 89) continue;

					//Hand B Use Case
					//2007.08.30
					Temp = extend_value * (-1);
					if (j >= 57 && j <= 68) {
						for ( k = 0 ; k < IMAGE_POLYGON_TABLE[IMAGE_TABLE[j].Pointer].len ; k++ ) {
							rotate( Point_Buffer_x[j][k] , Point_Buffer_y[j][k] , 0 , 3*zoom , Temp*(-0.7) , &Point_Buffer_x[j][k] , &Point_Buffer_y[j][k] );
						}
					} else if ((j >= 69 && j <= 82) || (j >= 90 && j <= 96)) {
						for ( k = 0 ; k < IMAGE_POLYGON_TABLE[IMAGE_TABLE[j].Pointer].len ; k++ ) {
							//rotate( Point_Buffer_x[j][k] , Point_Buffer_y[j][k] , 0 , extend_value , 0 , &Point_Buffer_x[j][k] , &Point_Buffer_y[j][k] );
							//mgsong
							Point_Buffer_y[j][k] += Temp*1.4;
						}
					} else {
						for ( k = 0 ; k < IMAGE_POLYGON_TABLE[IMAGE_TABLE[j].Pointer].len ; k++ ) {
						rotate( Point_Buffer_x[j][k] , Point_Buffer_y[j][k] , 0 , 3*zoom , Temp*0.7 , &Point_Buffer_x[j][k] , &Point_Buffer_y[j][k] );
						}
					}
				} else {
				}
				break;
			case DRAW_TEXT :
				if (extend_value > 0) {
					//Animate Arm Check
					if (j >= 45 && j <= 82) continue;
					if (j >= 90 && j <= 96) continue;

					//Hand A Use Case
					if (j >= 17 && j <= 28) {
						//2007.08.30
						if (j >= 17 && j <= 22)  
							rotate( Point_Buffer_x[j][0] , Point_Buffer_y[j][0] , 0 , 2*zoom , extend_value*(-1) , &Point_Buffer_x[j][0] , &Point_Buffer_y[j][0] );
						else
							rotate( Point_Buffer_x[j][0] , Point_Buffer_y[j][0] , 0 , 4*zoom , extend_value*(-0.7) , &Point_Buffer_x[j][0] , &Point_Buffer_y[j][0] );
					} else if ((j >= 29 && j <= 42) || (j >= 83 && j <= 89)) {
						Point_Buffer_y[j][0] += extend_value*1.4;
					} else {
						//2007.08.30
						if (j >= 5 && j <= 10) 
							rotate( Point_Buffer_x[j][0] , Point_Buffer_y[j][0] , 0 , 2*zoom , extend_value*1 , &Point_Buffer_x[j][0] , &Point_Buffer_y[j][0] );
						else
							rotate( Point_Buffer_x[j][0] , Point_Buffer_y[j][0] , 0 , 4*zoom , extend_value*0.7 , &Point_Buffer_x[j][0] , &Point_Buffer_y[j][0] );
					}
				} else if (extend_value < 0) {
					//Animate Arm Check
					if (j >= 5  && j <= 44) continue;
					if (j >= 83 && j <= 89) continue;

					//Hand B Use Case
					//2007.08.30
					Temp = extend_value * (-1);
					if (j >= 57 && j <= 68) {
						rotate( Point_Buffer_x[j][0] , Point_Buffer_y[j][0] , 0 , 3*zoom , Temp*(-0.7) , &Point_Buffer_x[j][0] , &Point_Buffer_y[j][0] );
					} else if ((j >= 69 && j <= 82) || (j >= 90 && j <= 96)) {
						Point_Buffer_y[j][0] += Temp*1.4;
					} else {
						rotate( Point_Buffer_x[j][0] , Point_Buffer_y[j][0] , 0 , 3*zoom , Temp*0.7 , &Point_Buffer_x[j][0] , &Point_Buffer_y[j][0] );
					}
				} else {
				}
				break;
		}
	}

	for (j = 0 ; j <= 96 ; j++) {
		if ( !IMAGE_TABLE[j].Use ) continue;
		switch (IMAGE_TABLE[j].Type) {
			case DRAW_LINE :
				rotate( Point_Buffer_x[j][0] , Point_Buffer_y[j][0] , 0 , 0 , rotate_value , &Point_Buffer_x[j][0] , &Point_Buffer_y[j][0] );
				rotate( Point_Buffer_x[j][1] , Point_Buffer_y[j][1] , 0 , 0 , rotate_value , &Point_Buffer_x[j][1] , &Point_Buffer_y[j][1] );
				break;
			case DRAW_CIRCLE :
				rotate( Point_Buffer_x[j][0] , Point_Buffer_y[j][0] , 0 , 0 , rotate_value , &Point_Buffer_x[j][0] , &Point_Buffer_y[j][0] );
				break;
			case DRAW_POLYGON :
				for (k = 0 ; k < IMAGE_POLYGON_TABLE[IMAGE_TABLE[j].Pointer].len ; k++) {
					rotate( Point_Buffer_x[j][k] , Point_Buffer_y[j][k] , 0 , 0 , rotate_value , &Point_Buffer_x[j][k] , &Point_Buffer_y[j][k] );
				}
				break;
			case DRAW_TEXT :
				rotate( Point_Buffer_x[j][0] , Point_Buffer_y[j][0] , 0 , 0 , rotate_value , &Point_Buffer_x[j][0] , &Point_Buffer_y[j][0] );
				break;
		}
	}


	//Draw Order Change
	for (j = 0 ; j <= 2 ; j++) {		
		if (!IMAGE_TABLE[j].Use ) continue;
		switch( IMAGE_TABLE[j].Type ) {
			case DRAW_LINE :
				DRAW_Line( hDC , hPal , (int) Point_Buffer_x[j][0] + x , (int) Point_Buffer_y[j][0] + y , (int) Point_Buffer_x[j][1] + x , (int) Point_Buffer_y[j][1] + y , IMAGE_LINE_TABLE[IMAGE_TABLE[j].Pointer].ecolor );
				break;
			case DRAW_CIRCLE :
				DRAW_Circle( hDC , hPal , (int) (Point_Buffer_x[j][0] - Point_Buffer_x[j][1]) + x , (int) (Point_Buffer_y[j][0] - Point_Buffer_y[j][1]) + y , (int) (Point_Buffer_x[j][0] + Point_Buffer_x[j][1]) + x , (int) (Point_Buffer_y[j][0] + Point_Buffer_y[j][1]) + y , IMAGE_CIRCLE_TABLE[IMAGE_TABLE[j].Pointer].fcolor , IMAGE_CIRCLE_TABLE[IMAGE_TABLE[j].Pointer].ecolor );
				break;
			case DRAW_POLYGON :
				for ( k = 0 ; k < IMAGE_POLYGON_TABLE[IMAGE_TABLE[j].Pointer].len ; k++ ) {
					PointArray[k].x = (int) Point_Buffer_x[j][k] + x;
					PointArray[k].y = (int) Point_Buffer_y[j][k] + y;
				}
				DRAW_PolyGon( hDC , hPal , PointArray , IMAGE_POLYGON_TABLE[IMAGE_TABLE[j].Pointer].len , IMAGE_POLYGON_TABLE[IMAGE_TABLE[j].Pointer].fcolor , IMAGE_POLYGON_TABLE[IMAGE_TABLE[j].Pointer].ecolor );
				break;
			case DRAW_TEXT :
				switch( IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].datap ) {
				case -1 : sprintf( Buffer , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].format , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].option ); break;
				case 0  : sprintf( Buffer , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].format , FingerA_Status + IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].option ); break;
				case 1  : sprintf( Buffer , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].format , FingerB_Status + IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].option ); break;
				case 2  : sprintf( Buffer , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].format , FingerA_Source + IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].option ); break;
				case 3  : sprintf( Buffer , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].format , FingerB_Source + IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].option ); break;
				case 4  : sprintf( Buffer , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].format , FingerA_Use + IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].option ); break;
				case 5  : sprintf( Buffer , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].format , FingerB_Use + IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].option ); break;
				case 6  : sprintf( Buffer , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].format , rotate_value + IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].option ); break;
				case 7  : sprintf( Buffer , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].format , extend_value + IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].option ); break;
				case 8  : sprintf( Buffer , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].format , Wafer_Mask_Mode + IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].option ); break;
				case 9  : sprintf( Buffer , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].format , zoom + IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].option ); break;
				case 10 : sprintf( Buffer , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].format , s ); break;
				case 11 : sprintf( Buffer , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].format , sp1 ); break;
				case 12 : sprintf( Buffer , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].format , sp2 ); break;
				case 13 : sprintf( Buffer , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].format , sp3 ); break;
				}
				
				DRAW_Text( hDC , hPal , (int) (Point_Buffer_x[j][0] + Point_Buffer_x[j][1]) + x , (int) (Point_Buffer_y[j][0] + Point_Buffer_y[j][1]) + y , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].size , Buffer ,IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].tcolor);
				break;
		}
	}

	for (j = 43 ; j <= 82 ; j++) {		
		if (!IMAGE_TABLE[j].Use ) continue;
		switch( IMAGE_TABLE[j].Type ) {
			case DRAW_LINE :
				DRAW_Line( hDC , hPal , (int) Point_Buffer_x[j][0] + x , (int) Point_Buffer_y[j][0] + y , (int) Point_Buffer_x[j][1] + x , (int) Point_Buffer_y[j][1] + y , IMAGE_LINE_TABLE[IMAGE_TABLE[j].Pointer].ecolor );
				break;
			case DRAW_CIRCLE :
				DRAW_Circle( hDC , hPal , (int) (Point_Buffer_x[j][0] - Point_Buffer_x[j][1]) + x , (int) (Point_Buffer_y[j][0] - Point_Buffer_y[j][1]) + y , (int) (Point_Buffer_x[j][0] + Point_Buffer_x[j][1]) + x , (int) (Point_Buffer_y[j][0] + Point_Buffer_y[j][1]) + y , IMAGE_CIRCLE_TABLE[IMAGE_TABLE[j].Pointer].fcolor , IMAGE_CIRCLE_TABLE[IMAGE_TABLE[j].Pointer].ecolor );
				break;
			case DRAW_POLYGON :
				for ( k = 0 ; k < IMAGE_POLYGON_TABLE[IMAGE_TABLE[j].Pointer].len ; k++ ) {
					PointArray[k].x = (int) Point_Buffer_x[j][k] + x;
					PointArray[k].y = (int) Point_Buffer_y[j][k] + y;
				}
				DRAW_PolyGon( hDC , hPal , PointArray , IMAGE_POLYGON_TABLE[IMAGE_TABLE[j].Pointer].len , IMAGE_POLYGON_TABLE[IMAGE_TABLE[j].Pointer].fcolor , IMAGE_POLYGON_TABLE[IMAGE_TABLE[j].Pointer].ecolor );
				break;
			case DRAW_TEXT :
				switch( IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].datap ) {
				case -1 : sprintf( Buffer , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].format , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].option ); break;
				case 0  : sprintf( Buffer , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].format , FingerA_Status + IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].option ); break;
				case 1  : sprintf( Buffer , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].format , FingerB_Status + IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].option ); break;
				case 2  : sprintf( Buffer , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].format , FingerA_Source + IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].option ); break;
				case 3  : sprintf( Buffer , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].format , FingerB_Source + IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].option ); break;
				case 4  : sprintf( Buffer , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].format , FingerA_Use + IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].option ); break;
				case 5  : sprintf( Buffer , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].format , FingerB_Use + IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].option ); break;
				case 6  : sprintf( Buffer , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].format , rotate_value + IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].option ); break;
				case 7  : sprintf( Buffer , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].format , extend_value + IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].option ); break;
				case 8  : sprintf( Buffer , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].format , Wafer_Mask_Mode + IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].option ); break;
				case 9  : sprintf( Buffer , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].format , zoom + IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].option ); break;
				case 10 : sprintf( Buffer , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].format , s ); break;
				case 11 : sprintf( Buffer , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].format , sp1 ); break;
				case 12 : sprintf( Buffer , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].format , sp2 ); break;
				case 13 : sprintf( Buffer , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].format , sp3 ); break;
				}
				
				DRAW_Text( hDC , hPal , (int) (Point_Buffer_x[j][0] + Point_Buffer_x[j][1]) + x , (int) (Point_Buffer_y[j][0] + Point_Buffer_y[j][1]) + y , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].size , Buffer ,IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].tcolor);
				break;
		}
	}

	for (j = 90 ; j <= 96 ; j++) {		
		if (!IMAGE_TABLE[j].Use ) continue;
		switch( IMAGE_TABLE[j].Type ) {
			case DRAW_LINE :
				DRAW_Line( hDC , hPal , (int) Point_Buffer_x[j][0] + x , (int) Point_Buffer_y[j][0] + y , (int) Point_Buffer_x[j][1] + x , (int) Point_Buffer_y[j][1] + y , IMAGE_LINE_TABLE[IMAGE_TABLE[j].Pointer].ecolor );
				break;
			case DRAW_CIRCLE :
				DRAW_Circle( hDC , hPal , (int) (Point_Buffer_x[j][0] - Point_Buffer_x[j][1]) + x , (int) (Point_Buffer_y[j][0] - Point_Buffer_y[j][1]) + y , (int) (Point_Buffer_x[j][0] + Point_Buffer_x[j][1]) + x , (int) (Point_Buffer_y[j][0] + Point_Buffer_y[j][1]) + y , IMAGE_CIRCLE_TABLE[IMAGE_TABLE[j].Pointer].fcolor , IMAGE_CIRCLE_TABLE[IMAGE_TABLE[j].Pointer].ecolor );
				break;
			case DRAW_POLYGON :
				for ( k = 0 ; k < IMAGE_POLYGON_TABLE[IMAGE_TABLE[j].Pointer].len ; k++ ) {
					PointArray[k].x = (int) Point_Buffer_x[j][k] + x;
					PointArray[k].y = (int) Point_Buffer_y[j][k] + y;
				}
				DRAW_PolyGon( hDC , hPal , PointArray , IMAGE_POLYGON_TABLE[IMAGE_TABLE[j].Pointer].len , IMAGE_POLYGON_TABLE[IMAGE_TABLE[j].Pointer].fcolor , IMAGE_POLYGON_TABLE[IMAGE_TABLE[j].Pointer].ecolor );
				break;
			case DRAW_TEXT :
				switch( IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].datap ) {
				case -1 : sprintf( Buffer , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].format , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].option ); break;
				case 0  : sprintf( Buffer , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].format , FingerA_Status + IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].option ); break;
				case 1  : sprintf( Buffer , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].format , FingerB_Status + IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].option ); break;
				case 2  : sprintf( Buffer , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].format , FingerA_Source + IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].option ); break;
				case 3  : sprintf( Buffer , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].format , FingerB_Source + IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].option ); break;
				case 4  : sprintf( Buffer , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].format , FingerA_Use + IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].option ); break;
				case 5  : sprintf( Buffer , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].format , FingerB_Use + IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].option ); break;
				case 6  : sprintf( Buffer , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].format , rotate_value + IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].option ); break;
				case 7  : sprintf( Buffer , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].format , extend_value + IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].option ); break;
				case 8  : sprintf( Buffer , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].format , Wafer_Mask_Mode + IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].option ); break;
				case 9  : sprintf( Buffer , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].format , zoom + IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].option ); break;
				case 10 : sprintf( Buffer , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].format , s ); break;
				case 11 : sprintf( Buffer , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].format , sp1 ); break;
				case 12 : sprintf( Buffer , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].format , sp2 ); break;
				case 13 : sprintf( Buffer , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].format , sp3 ); break;
				}
				
				DRAW_Text( hDC , hPal , (int) (Point_Buffer_x[j][0] + Point_Buffer_x[j][1]) + x , (int) (Point_Buffer_y[j][0] + Point_Buffer_y[j][1]) + y , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].size , Buffer ,IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].tcolor);
				break;
		}
	}

	for (j = 3 ; j <= 42 ; j++) {
		if (!IMAGE_TABLE[j].Use ) continue;
		switch( IMAGE_TABLE[j].Type ) {
			case DRAW_LINE :
				DRAW_Line( hDC , hPal , (int) Point_Buffer_x[j][0] + x , (int) Point_Buffer_y[j][0] + y , (int) Point_Buffer_x[j][1] + x , (int) Point_Buffer_y[j][1] + y , IMAGE_LINE_TABLE[IMAGE_TABLE[j].Pointer].ecolor );
				break;
			case DRAW_CIRCLE :
				DRAW_Circle( hDC , hPal , (int) (Point_Buffer_x[j][0] - Point_Buffer_x[j][1]) + x , (int) (Point_Buffer_y[j][0] - Point_Buffer_y[j][1]) + y , (int) (Point_Buffer_x[j][0] + Point_Buffer_x[j][1]) + x , (int) (Point_Buffer_y[j][0] + Point_Buffer_y[j][1]) + y , IMAGE_CIRCLE_TABLE[IMAGE_TABLE[j].Pointer].fcolor , IMAGE_CIRCLE_TABLE[IMAGE_TABLE[j].Pointer].ecolor );
				break;
			case DRAW_POLYGON :
				for ( k = 0 ; k < IMAGE_POLYGON_TABLE[IMAGE_TABLE[j].Pointer].len ; k++ ) {
					PointArray[k].x = (int) Point_Buffer_x[j][k] + x;
					PointArray[k].y = (int) Point_Buffer_y[j][k] + y;
				}
				DRAW_PolyGon( hDC , hPal , PointArray , IMAGE_POLYGON_TABLE[IMAGE_TABLE[j].Pointer].len , IMAGE_POLYGON_TABLE[IMAGE_TABLE[j].Pointer].fcolor , IMAGE_POLYGON_TABLE[IMAGE_TABLE[j].Pointer].ecolor );
				break;
			case DRAW_TEXT :
				switch( IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].datap ) {
				case -1 : sprintf( Buffer , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].format , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].option ); break;
				case 0  : sprintf( Buffer , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].format , FingerA_Status + IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].option ); break;
				case 1  : sprintf( Buffer , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].format , FingerB_Status + IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].option ); break;
				case 2  : sprintf( Buffer , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].format , FingerA_Source + IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].option ); break;
				case 3  : sprintf( Buffer , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].format , FingerB_Source + IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].option ); break;
				case 4  : sprintf( Buffer , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].format , FingerA_Use + IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].option ); break;
				case 5  : sprintf( Buffer , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].format , FingerB_Use + IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].option ); break;
				case 6  : sprintf( Buffer , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].format , rotate_value + IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].option ); break;
				case 7  : sprintf( Buffer , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].format , extend_value + IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].option ); break;
				case 8  : sprintf( Buffer , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].format , Wafer_Mask_Mode + IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].option ); break;
				case 9  : sprintf( Buffer , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].format , zoom + IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].option ); break;
				case 10 : sprintf( Buffer , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].format , s ); break;
				case 11 : sprintf( Buffer , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].format , sp1 ); break;
				case 12 : sprintf( Buffer , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].format , sp2 ); break;
				case 13 : sprintf( Buffer , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].format , sp3 ); break;
				}
				
				DRAW_Text( hDC , hPal , (int) (Point_Buffer_x[j][0] + Point_Buffer_x[j][1]) + x , (int) (Point_Buffer_y[j][0] + Point_Buffer_y[j][1]) + y , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].size , Buffer ,IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].tcolor);
				break;
		}
	}

	for (j = 83 ; j <= 89 ; j++) {		
		if (!IMAGE_TABLE[j].Use ) continue;
		switch( IMAGE_TABLE[j].Type ) {
			case DRAW_LINE :
				DRAW_Line( hDC , hPal , (int) Point_Buffer_x[j][0] + x , (int) Point_Buffer_y[j][0] + y , (int) Point_Buffer_x[j][1] + x , (int) Point_Buffer_y[j][1] + y , IMAGE_LINE_TABLE[IMAGE_TABLE[j].Pointer].ecolor );
				break;
			case DRAW_CIRCLE :
				DRAW_Circle( hDC , hPal , (int) (Point_Buffer_x[j][0] - Point_Buffer_x[j][1]) + x , (int) (Point_Buffer_y[j][0] - Point_Buffer_y[j][1]) + y , (int) (Point_Buffer_x[j][0] + Point_Buffer_x[j][1]) + x , (int) (Point_Buffer_y[j][0] + Point_Buffer_y[j][1]) + y , IMAGE_CIRCLE_TABLE[IMAGE_TABLE[j].Pointer].fcolor , IMAGE_CIRCLE_TABLE[IMAGE_TABLE[j].Pointer].ecolor );
				break;
			case DRAW_POLYGON :
				for ( k = 0 ; k < IMAGE_POLYGON_TABLE[IMAGE_TABLE[j].Pointer].len ; k++ ) {
					PointArray[k].x = (int) Point_Buffer_x[j][k] + x;
					PointArray[k].y = (int) Point_Buffer_y[j][k] + y;
				}
				DRAW_PolyGon( hDC , hPal , PointArray , IMAGE_POLYGON_TABLE[IMAGE_TABLE[j].Pointer].len , IMAGE_POLYGON_TABLE[IMAGE_TABLE[j].Pointer].fcolor , IMAGE_POLYGON_TABLE[IMAGE_TABLE[j].Pointer].ecolor );
				break;
			case DRAW_TEXT :
				switch( IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].datap ) {
				case -1 : sprintf( Buffer , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].format , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].option ); break;
				case 0  : sprintf( Buffer , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].format , FingerA_Status + IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].option ); break;
				case 1  : sprintf( Buffer , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].format , FingerB_Status + IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].option ); break;
				case 2  :{
					// Dummy Wafer Source 
					if (FingerA_Source >= 5)
						FingerA_Source = 3;					
					sprintf( Buffer , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].format , FingerA_Source + IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].option ); break;
				}
				case 3  :{
					// Dummy Wafer Source
					if (FingerB_Source >= 5)
						FingerB_Source = 3;
					sprintf( Buffer , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].format , FingerB_Source + IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].option ); break;
				}
				case 4  : sprintf( Buffer , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].format , FingerA_Use + IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].option ); break;
				case 5  : sprintf( Buffer , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].format , FingerB_Use + IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].option ); break;
				case 6  : sprintf( Buffer , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].format , rotate_value + IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].option ); break;
				case 7  : sprintf( Buffer , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].format , extend_value + IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].option ); break;
				case 8  : sprintf( Buffer , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].format , Wafer_Mask_Mode + IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].option ); break;
				case 9  : sprintf( Buffer , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].format , zoom + IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].option ); break;
				case 10 : sprintf( Buffer , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].format , s ); break;
				case 11 : sprintf( Buffer , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].format , sp1 ); break;
				case 12 : sprintf( Buffer , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].format , sp2 ); break;
				case 13 : sprintf( Buffer , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].format , sp3 ); break;
				}
				
				DRAW_Text( hDC , hPal , (int) (Point_Buffer_x[j][0] + Point_Buffer_x[j][1]) + x , (int) (Point_Buffer_y[j][0] + Point_Buffer_y[j][1]) + y , IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].size , Buffer ,IMAGE_TEXT_TABLE[IMAGE_TABLE[j].Pointer].tcolor);
				break;
		}
	}
}
