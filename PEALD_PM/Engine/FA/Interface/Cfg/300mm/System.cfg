#---------------------------------------------------------------------------------
#	COMMUNICATION PART
#
#   	COMM_METHOD	: HSMS , RS232(not yet ready)
#	COMM_TRY	: PASSIVE , ACTIVE
#	COMM_IP		: ""(local) or "PC Name" or "IP Addr" => only ACTIVE
#	COMM_PORT	: TCP/IP Port => No 5001-5020( Already Used CTC ) 
#	COMM_INIT	: DISABLE , ENABLE
#	COMM_NET_MONITOR: DISABLE , ENABLE( Enable = Lan Cable Remove Monitoring Start )
#---------------------------------------------------------------------------------
COMM_METHOD		HSMS
COMM_TRY		PASSIVE
COMM_IP			""	
COMM_PORT		6000
COMM_INIT		ENABLE
COMM_NET_MONITOR	DISABLE		

#---------------------------------------------------------------------------------
#	DATA LOGGING PART
#
#   	DATALOG_ENABLE	: DISABLE , ENABLE
#	DATALOG_PATH	: Data Logging File Location Directory Path 
#	LOG_DELETE_DAY	: Data Log File Delete Interval Day( 0 <= x <= 365 ), 0 = No Delete
#	DEBUGLOG_ENABLE	: Determine a logging to debug( DISABLE , ENABLE )
#---------------------------------------------------------------------------------
DATALOG_ENABLE		ENABLE
DATALOG_PATH		DATALOG\GEM
LOG_DELETE_DAY		10
DEBUGLOG_ENABLE		DISABLE

#---------------------------------------------------------------------------------
#	GEM SYSTEM and CONFIG PART
#
#   	DEVICE_ID		: Equipment Number( 0 - 65535 )
#	RECONNECT_INIT		: NO , YES -> When TCPIP Reconnect, Whether Parameter Initialize( Queue , Online etc )
#	RETURN_ONLINE_STATUS	: when reconnect after disconnect from Host in online remote or local, return in pre online status( YES : return, NO : no return )
#	RETURN_RECONNECT_TIME	: Time to return after reconnect( 0 <= x <= 99999 Sec, 0 : Always )
#	RETURN_PREMODE_DISCONBYEQ : When reconnect after disconnect from Equip. in online remote or local, return in pre online status( YES : return, NO : no return )
#	LINKTEST_ENABLE		: DISABLE , ENABLE
#	LINKTEST_SEND_MODE	: Determine a time to send the linktest message( I=Idle Time,S=Secodary Message,A=Active Mode,F=Fixed Time,B=PASSIVE+ACTIVE=Both )
#				  I+S+A => Idle+Secondary+Active, I+S+B => Idle+Secondary+Both, I+A => Idle+Active, I+B = Idle+Both
#				  F+S+A => Fixed+Secondary+Active, F+S+B => Fixed+Secondary+Both, F+A => Fixed+Active, F+B => Fixed+Both
#	IDLE_LINKTEST_TIME	: No Transfer Message( = IDLE ), LINKTEST Start Time(Sec, 5-3600Sec)
#	S6F2RESP_ENABLE		: if determin S6F1->S6F2 Received , DISABLE = not receive, ENABLE = receive
#	S6F12RESP_ENABLE	: if determin S6F11->S6F12 Received , DISABLE = not receive, ENABLE = receive
#	S6F14RESP_ENABLE	: if determin S6F13->S6F14 Received , DISABLE = not receive, ENABLE = receive
#	ATTEMPT_ESTABLISH	: NO , YES -> Attempt Comm Establish(S1F13) to Host, ESTABLISH_CHECK = YES Valid
#	ESTABLISH_CHECK 	: NO , YES -> if Adapt or not S1F13
#	RSPMSG_RETRY_COUNT	: Response Message Waiting Retry Count( -1 <= x <= 100 ), -1 : When Response Timeout, Continuously Retry
#	EVENTDEF_MODE 		: (Event Define Mode) RECV(Receive Type) , SAVE(Save Type)
#			  	  RECV -> Always Receive at Init from Host
#			  	  SAVE -> Defines from Saved file
#	FORMAT_EVENT_TYPE	: Case CEID, if CEID Event Type is Format, Event Type is selected( S6F3 or S6F9 )
#	NOTIFY_EVENT_TYPE	: Case CEID, if CEID Event Type is Notify, Event Type is selected( S16F7 or S16F9 )
#	NORMAL_EVENT_TYPE	: Case CEID, if CEID Event Type is Normal, Event Type is selected( S6F11 or S6F13 )
# 	REMOTE_INIT_SET 	: LOCAL , REMOTE , PREVIOUS -> When Online, Online Init Mode, Remote Parameter Init Value
#	ONLINE_EVENT_TYPE	: When Online Event Occur, Event Type Send to Host. BOTH : after ONLINE Event, Current State(LOCAL/REMOTE) Send, ONLINE : only ONLINE Event Send, STATE : Current State(LOCAL/REMOTE) Send, ONLINE_MID : ONLINE Event and MID Port Event Send
#	OFFL_MESSAGE_LIMIT	: When Offline, Message Limit Send to HOST( FULL : All Event Message Send in Offline/Online, LIMIT : on Online, can send Event Message , REJECT : when Offlen, All Message Reject, except comm message )
#	REPORT_ALREADY_OFFLINE	: When Equipment is already OFFLINE mode, Response Type for Message( NOTACK : S1F16 ACK = 0x02, ABORT : S1F0 )
#	RES_FOR_S1F1_IN_OFFLINE	: When Equipment is Offline mode, Response for S1F1( ONLINE : Transition to Online, ABORT : S1F0 )
#	DMYWFR_PMEVENT_MODE	: In the case of Dummy Wafer, determint to happen the PM Process Start/End/StepChange Event( NO : No Happen, YES : Happen(default) )
#	CARCOMPLETE_EVENT_MODE	: When CarrierStop Event Occur, Determine to Report the CarrierComplete Event( NO : No Report, YES : Event Report )
#	LOTCLT_PPID_EDIT_EVENT	: When Lot/Cluster Recipe(PPID) is Edited, Determine to occur the Event for Edit( NO : No Event Only a Event of PM Edit will happen, YES : Happen )
#	PPID_EDIT_DETAIL_EVENT	: When a Recipe(PPID) is Edited, Define what kind of event occur( NO : Only RECIPE_EDIT event will occur, YES : CREATE or UPDATE or DELETE event will occur )
#	PPID_EDIT_REPORT_MODE	: When PPID Edit Event is reported( ALLGRP+USEGN : Report for All Group and GroupName(default), ALLGRP+NOGN : Report for All Group but Remove GroupName, FIXGRP+USEGN : Report for Fixed Group and GroupName, FIXGRP+NOGN : Report for Fixed Group but remove GroupName )
#	PORT_EVENT_IN_300mm	: Determine the type option which happen the Port Event in 300mm( COMMON : Same CEID is used, PRCSEND : Port Process End Event happen as each Port CEID, ALL : Port Related Event Happen as each Port CEID, EXCEPT_WFRSTS : Except substrate event per wafer from ALL option )
#	PROCES_EVENT_IN_300mm	: PM Process Event in 300mm( In Process/Step Change/Out Process : COMMON, SEPARATE for each CEID of PM )
#	PRCS_STEP_EVT_IN_300mm	: When Process Step Event happen, Determine which use for Step event( CHANGED : STEP CHANGE Event Happen, STARTEND : STEP START/END Event Happen for Single Process Recipe, STARTEND_M : STEP START/END Event Happen for Multi Process Recipe )
#	PRCS_ABNML_EVT_IN_300mm	: When Process is finished abnormally, Determine which event use( PROCESSED : Normal Processed Event, ABNORMAL : Abnormal Processed Event )
#	SUBSTNEEDPRCS_EVENT_POS	: Determine the Report Position of Subst Need Process Event( PRCSMDL : Report before each PM Process Start, LOADPORT : Only One Report after Mapping on LoadPort , PORT+PMEND : Only One Report after Mapping and Report after each PM Process End(SEMI Type) )
#	NOBIND_BYPASSON_EVENT	: Determine the Event for No Bind and Bypass is On( WFH_EVENT : CARRIER_ID_WFH_FROM_READFAIL Event is reported, READFAIL_EVENT : CARRIER_ID_READ_FAIL Event is reported(SEMI Type) )
#	NOBIND_IDREADFAIL_EVENT	: Determine the Event for when No Bind and Bypass is On, ID Reader is failed( WFH_EVENT : CARRIER_ID_WFH_FROM_READFAIL Event is reported, READFAIL_EVENT : CARRIER_ID_READ_FAIL Event is reported(SEMI Type) ) 
#	EVERY_SUBST_EVT_OF_PORT	: Determine to report the Every Substrate Event for Port( NO : No Report, WAFER : Report for Only Present Wafer(SEMI Type), SLOT : Report for All Slot )
#	EVERY_SUBST_OCCUPY_EVT	: Determine the Report Type for Subst Occupy or Unoccupy Event of Port( PER_WAFER : SUBST_OCCUPIED_PER_WAFER/SUBST_UNOCCUPIED_PER_WAFER is used, LOCATION : SUBST_LOCATION_OCCUPIED/SUBST_LOCATION_UNOCCUPIED is used )
#	EVERY_SUBST_NEEDPRS_EVT	: Determine the Report Type for Subst NeedProcess Event of Port( PER_WAFER : SUBST_NEEDPROCESSING_PET_WAFER is used, NEED_PRCS : NEED_PROCESSING is used for Normal Subst Need Process Event in PM )
#	CAR_NOTASSOCIATED_EVENT : Determine the Report Type of Carrier Not Associated Event( ALWAYS : Always it is reported when carrier is removed, TRANSITION : it is reported when carrier is changed from Associate to Notassociate )
#	DATA_COLLECT_EVENT_RPT	: Determine to Report the Data Collection Event at the same time, when Step End, Recipe End and Wafer End Event is Reported to Host( NO : Event No Send, YES : Event Report )
#	HOSTGUI_PPID_EDIT_EVENT : Determine the report type of event for PPID Edit from Host or GUI( COMMON : Same CEID, SEPARATE : Different CEID )
#	HOSTGUI_EC_CHANGE_EVENT	: Determine the report type of event for ECID Change from Host or GUI( COMMON : Same CEID, SEPARATE : Different CEID ) 
#	SPOOL_MODE		: Spooling Mode, RECV(Receive Type) , SAVE(Save Type)
#			  	  RECV -> Always Receive at Init from Host
#			  	  SAVE -> Defines from Saved file
#	MAX_SPOOL_MESSAGE	: Spooled Max Message Numbers( 0 <= x <= 1000 )
#	SPMSG_RESP_ENABLE	: Spool Message Wait Bit En/Disable Set( ENABLE : Wait, DISABLE : Not Wait )
#	REJECT_MSG_SPOOL	: When Connection, as Offline/Local Condition, a rejected message Spooling( ENABLE : Spool , DISABLE : discard(not spool) )
#	TERMINAL_MSG_SEP	: Terminal Send/Receive Message Separation for IO, YES = Separation( Send = GEM.Terminal_SendMsg, Recv = GEM.Terminal_Msg ) , NO = Common( GEM.Terminal_Msg )
#	MSGBOX_BIGFONT_USE	: Determine to use Message Box Big Font ( YES = Big Font Use, NO = Not Use )
#	MESSAGE_BOX_STYPE	: Message Box Popup Style( CONFIRM : need user confirm, UPDATE : new message update, AUTODEL_C : after specific time, auto deletion and when Popup, remessage CONFIRM type,
#				  AUTODEL_U : after specific time, auto deletion and when Popup, remessage UPDATE type )
#	MSGBOX_AUTODLE_TIME	: Case Message Box Style is AUTODLE, Auto Delete Time( 0 < time <= 3600 ), units is 'sec'
#	VERIFYMSG_BOX_STYLE	: Verify Message Box Popup Style( CONFIRM : need user confirm, UPDATE : new message update, AUTODEL_C : after specific time, auto deletion and when Popup, remessage CONFIRM type,
#				  AUTODEL_U : after specific time, auto deletion and when Popup, remessage UPDATE type )
#	VERIFYMB_AUTODEL_TIME	: Case Verify Message Box Style is AUTODLE, Auto Delete Time( 0 < time <= 3600 ), units is 'sec'
#	MID_VERIFY_TYPE		: MID Direct Type( MID ), Page Type Verify( PAGE )
#	MID_x_ACTION_TYPE	: MID Action Type in S18F5,7,9,11( ACTUAL : HW read/write, VIRTUAL : IO read/write, THREAD : Thread for read/Write ), RF DATA Read/Write Same
#	GEM_SERVER_ON_IO	: GEM Server IO Define for Communicate with CTC
#   	GEM_EQUIP_TYPE		: 200mm , 300mm
#	CLUSTER_TYPE		: Cluser = CTC , Stand alone = PMC
#	HISTORY_CHAMBER_ORDER	: Wafer Chamber Path History Order, USING_BASE = PM Count, MODULE_BASE = PM Number : Valid in the Case of only HISTORY_LOG_TYPE = ORDER_BASED
#	HISTORY_LOG_TYPE	: When Histroy Data is logged, logged data type. 
#				  ORDER_BASED : logged by Chamber Order, NAME_BASED : logged by LOCATION NAME
#	HISTORY_WFR_SYNCH_CHECK	: When log the history data or get the history data, determine to check the wafer synch for really wafer present( YES : Synch check except PM, NO : No Check, YES+PM : Synch check included PM )
#	PRJOB_AUTO_DELETE	: When CTLJOB is deleted, determine to delete automatically a PRJOB liked the CTLJOB
#	PJCOMPLT_EVENT_DETAIL	: When PRJOB is completed, determine weather only PRJOB_COMPLETE or as Result( NO : PRJOB_COMPLETE, YES : as Result )
#	CJCOMPLT_EVENT_DETAIL	: When CTRLJOB is completed, determine weather only CTRLJOB_COMPLETE or as Result( NO : CTRLJOB_COMPLETE, YES : as Result )
#	PJCOMPLT_EVT_INABORT	: When a Job is Aborted or Cancelled, determine PRJOB Complete Event happen( NO : No Happen, YES : Happen )
#	CJCOMPLT_EVT_INABORT	: When a Job is Aborted or Cancelled, determine CTLJOB Complete Event happen( NO : No Happen, YES : Happen )
#	JOB_USER_LEVEL_INTLK	: Determine the user level to control Action Button in Job Manager Screen(level >= 0 ), 300mm spec
#	S14F9_MTRLOUTSPEC_TYPE	: In S14F9 SECS Message Structure, determine the MTRLOUTSPEC type( COMMON : default spec(old semi,default), SEPARATE : current semi( in/out information is separated ) )
#	JOB_STARTMODE_TYPE	: In S14F9/S16F11/13/15, determine the StartMethod of Job( REVERSE : reverse from semi( default, 0 = auto, 1 = manual ), SEMI : semi spec( 0 = manual, 1 = auto ) )
#	CJ_COMMAND_TYPE		: Control Job Command Type( DEFAULT(0~7):Start,Pause,Resume,Cancel,Deselect,Stop,Abort,HOQ;	TYPE1(1~8):Start,Pause,Resume,Cancel,Deselect,Stop,Abort,HOQ )
#	S14F11_OBJSPEC_TYPE	: In S14F11, OBJSPEC is Attribute ID or ControlJob ID( ATTRID : Attribute ID, CTRLJOBID : Control Job ID )
#	PJ_RECIPEMETHOD_TYPE	: In Process Job, Recipe Method Type( RCP0_TUN1(default) : Only Recipe = 0, Tuning = 1, RCP1_TUN2 : Only Recipe = 1, Tuning = 2 )
#	QUEUEDJOB_CMD_REJECT	: Stop or Abort Command from Host is Rejected for a Queued Job( PJ and CJ ) ( NO : No Reject(Possible) YES : Reject(Impossible) )  
#	DESELECTTOQUEUE_EVENT	: Replace the Deselect Event to Queue Event( NO : DESELECT EVENT HAPPEN, YES : QUEUE EVENT HAPPEN )
#	PJPRCS_EVENT_IN_PJSTOP	: When PJ is stopping, determin to occur the PJProcessing and PJProcessCompleted Event( NO : No occur, YES : occur )
#	MTRL_SLOT_TYPE_IN_PJ	: When PJ is created, Determine to Define a Type of Slot Attribute in PJ Material Name List( SLOTID : Slot Number, SLOTMAP : Map Status )
#	S14F9_CJ_RESPONSE_TYPE	: Determine to reply for S14F9 CJ Creation( DEFAULT : CJ Data Response, SEMI : Only Acknowledge Response )
#	CJ_STOPABORT_EVENT_IN_Q	: Type to report the Event When CJ Stop/Abort Event happen in Queue or Select Status( NORMAL : Stop/Abort Event, COMPLETED : Stopped/Aborted Completed Event )
#	CJ_DEL_EVENT_TYPE_IN_Q	: When CJ is cancelled in Queue, Event Report Type( DELETE : Only CJ Delete Event Report, COMPLETE : Only CJ Queue Complete Event Report )
#	JOB_DELETED_IN_RTU	: When ReadyToUnload Event happen for a Carrier, then if a CJ/PJ exist with the CarrierID, the CJ/PJ will be deleted( NO : No Delete, YES : Delete )
#	PJ_RECID_FORMAT		: ProcessJob Recipe Name Format( NORMAL : "GROUPNAME,RECIPENAME", FULLNAME : "GROUPNAME|LOT|RECIPENAME" or "GROUPNAME|CLT|RECIPENAME" )
#	PJ_TUNING_FORMAT	: ProcessJob Tuning Data Format( NORMAL : "PMNAME,STEPNUMBER,ITEM", EXTEND : "PMNAME,PMRECIPENAME,STEPNUMBER,ITEM", INDEX : "PMNAME,MULTIRCPINDEX,STEPNUMBER,ITEM", INDEX is capable when Scheduler Tun Extend Option is used , INDEXPATH : "PMNAME,PATH,MULTIRCPINDEX,STEPNUMBER,ITEM", INDEXPATH is capable when Scheduler Tun Extend Option is used )
#	PJ_TUNING_TIME		: PJ Tuning Send Available Time(!6F23) : QUEUED, BEFORE_RUN, ALWAYS
#	PJ_SETUP_STS_SCENARIO	: Determine the PJ Setup Status scenario( S_B_R+P_A_R, Q_B_R+P_A_R, S_B_R+S_A_R, Q_B_R+S_A_R : S_B_R Queue = Setup Status Before Run, Q_B_R = Queue Status Before Run
#				  P_A_R : Processing Status After Run until PJ Processing Start, S_A_R : Setup Status After Run until PJ Processing Start )
#	PJ_PRCSCOM_STS_SCENARIO : Determine the PJ Processing Completed Status Scenario( NORMAL : Previous Type( after PJ Prcs Complete, Event is reported PJ Prcs Completed but status is "Procssing" ),
#				  COMPLETED : after PJ Prcs Completed Event is reported, status is "PJ Prcs Completed" )
#	PJ_RCPMODE_FOR_S16F23	: Determine if it change the Recipe Mode of PJ automatically when Host down S16F23 for only old tun memory( FIX : No change the Recipe Mode, AUTO : change the Recipe Mode )
#	PJ_MF_CHECK_TYPE	: Determine to check or not for MF Value when PJ is created( NOCHECK : MF is not checked, CARRIER : MF is valid only for Carrier Type )
#	PJ_DEL_EVENT_TYPE_IN_Q	: Determine to send the PJ Delete Event When a Queued PJ is deleted( SEND : Send(SEMI 0304 Version), NOSEND : Don't send(SEMI 1106 Version )
#	SCH_INTERFACE_FUNC	: Interface Function Name for scheduling between Scheduler and GEM
#	JOB_INTERFACE_FUNC	: Interface Function Name for job management between Scheduler and GEM
#	STEPDATA_ANALYSIS_USE	: When Step Change Event happens, it is that determines to use the Step Log Data Analysis Function
#	STEPDATA_ANALYSIS_FNC	: Function Name to analysis the Step Log Data
#	PRCSDATA_ANALYSIS_USE	: When Module Process End Event happens, it is that determines to use the Module Process End Log Data Analysis Function
#	PRCSDATA_ANALYSIS_FNC	: Function Name to analysis the Module Process End Log Data
#	LOTDATA_ANALYSIS_USE	: When Lot(Port) Process End Event happens, it is that determines to use the Lot(Port) Process End Data Analysis Function
#	LOTDATA_ANALYSIS_FNC	: Function Name to analysis the Lot(Port) Process End Log Data
#	PJDATA_ANALYSIS_USE	: When Process Job Complete Event happens, it is that determines to use the Process Job Complete Data Analysis Function
#	PJDATA_ANALYSIS_FNC	: Function Name to analysis the Process Job Log Data
#	TKINOUT_ANALYSIS_USE	: Determination to Use a Analysis Function for TRACK IN/OUT/CANCEL TERMINAL MESSAGE( YES : Use , NO : Not Use )
#	TKINOUT_ANALYSIS_FNC	: Case TKINOUT_TMSG_FNC_USE is YES, Analysis Function Name for TRACK IN/OUT/CANCEL TERMINAL MESSAGE
#	HOSTCMD_INTERFACE_FUNC	: Interface function name from host command( ex: Remote/Local/Online/Offline, RCMD, AMHS, CMS , CJOB , PJOB )
#	EVENT_INTERFACE_FUNC	: Interface function name when event happen from equipment
#	PPID_INTERFACE_FUNC	: Interface function name when PPID is uploaded or downloaded by host
#	PORT_LOCATIONID_TYPE	: LOCATIONID, CARRIERID
#				  When Port LocationID Set, determine to use CarrierID or to use LocationID under defined
#	LOCATIONID_NAME_xxx	: Equipment each Module Name Define for LocationID, xxx = Module Name
#				  LocationID Name Max String is 127 Byte
#	MODELNUMBER		: <= 6 Byte
#	SOFTVERSION		: <= 6 Byte
#	EXT_TERMINAL_BOX_USE	: Determine to use terminal message display in external function, because RCS
#	EXT_TERMINAL_BOX_FUNC	: External terminal display function name
#	CONTENTMAP_DATA_TYPE	: In Attribute, LotID/SlotID Data Configuration ( COMMON : Sequencial Ascii => "LotID,SlotID"(default) , SEPARATE : List Ascii )
#	LOCATIONID_DATA_TYPE	: In Attribute, LocationID Data Format Type ( ASCII : Location Name(default), UINT : Port Number )
#	SLOTMAP_DATA_TYPE	: In Attribute, SlotMap Data Type( LIST_NORMAL(default), LIST_EXTEND , SERIAL_NORMAL, SERIAL_EXTEND, LIST = List Format Type, SERIAL = Ascii Sequencial Type, NORMAL = 0(UNDEFINED) 1(EMPTY) 2(PRESENT) 3(DOUBLE) 4(CROSS), EXTEND = 0(UNDEFINED) 1(EMPTY) 2(NOTEMPTY) 3(NORMAL PRESENT) 4(DOUBLE) 5(CROSS) )
#	USAGE_DATA_TYPE		: In Attribute, Usage Response Data( SEMI : Produce, Dummy etc(default, wafer type), LOTID : LotID Data )
#	TUNING_DATA_SEP_CHAR	: Charater to separate the tuning data of Process Job( Default : ',' )
#	LOCID_DATA_SEP_CHAR	: Charater to separate between LocationID and Slot Number
#	S14F1_MF_REPORT_TYPE	: When MF is reportd in S14F1, SECS Message Format Type( ASCII, BINARY )
#	OBJ_REPORT_IN_OSS_FAIL	: When OBJID is failed in OSS S14F1/F3, OBJID Report Type of Response S14F2/F4 ( NONE : List is 0, ObjectID is none, OBJID : Report a OBJID for request of S14F1/F3 )
#	SUBST_SOURCE_DEST_DATA	: When Substrate AtSource/AtDestination Data is reported, the Content of Data( LOCATIONID , CARRIERID , LOCATIONID+SLOT , CARRIERID+SLOT )
#	DEST_DATA_WITH_SAME_SRC	: When Substrate AtDestination Data is reported with same source, the Content of Data( NULL , SOURCE )
#	SUBST_ATTRIBUTE_EXTEND	: Determine to extend the Attributes of Substrate( NO : No Extension, YES : Extension )
#	SUBST_LOCID_DETAIL	: When Substrate LocationID Data is filled in IO, Determine to write a LocationID String( NO : Only LocationID, YES : Detail, LocationID and Slot Data Combination )
#	SUBSTRATE_OBJTYPE	: Substrate OBJTYPE( OBJID = SubstrateID(WaferID) : COMMON, SEPARATE for each Port )
#	CAR_OBJECT_FOR_LIST_0	: Carrier Object Creation Mode for List 0( PORTBASE : Make the object as Port Number, CARRIERIDBASE : Make the object as CarrierID Read )
#	SUBSTID_FOR_UNOCCUPIED	: Determine the SubstID Data when Data is reported in Subst Location Unoccupied( WAFERID : WaferID of Substrate for SubstID Attribute and VID, ATTR_BLANK : only Attriubte Data Blan, BLANK : NULL Data for Attribute and VID )
#	WAFERIDLIST_FOR_EVENT	: Determine the WaferID List Data Format when a event is reported( ONLY_WAFER : List Report for Only Wafer Numbers , TOTAL_WAFER : All List Report for Total Slot Numbers of Port )
#	PRCSSTATE_FOR_PM_PRCSED	: Determine the Process State Data when All Path PM Processed Event is reported( NEEDPRCS : Need Process State, PROCESSED : Processed State )
#	USAGE_DATA_VALUE_TYPE	: Determine the Usage Data Value Type( PRODUCT_2 : 0=TEST 1=DUMMY 2=PRODUCT 3=FILLER 4=MONITOR 5=ETC, PRODUCT_0 : 0=PRODUCT 1=TEST 2=FILLER 3=MONITOR 4=DUMMY 5=ETC )
#	SUBST_HISTORY_REPORT	: Determine the Substrate History Report Type( ONLY_PM : Substrate History have only a PM data, PORT+PM : Substrate History have a Port and PM data, ALL : Substrate History have all station )
#	CARLOCMTX_REPORT_TYPE	: Determine the Report Type for CarrierLocationMatrixList( PORTBASE : Report for Port Numbers , POSBASE : Report for each position of Port Numbers , PORT_POS : Reprot the Port and each Position ,
#				  POSBASE2 : Report for each position of Port Numbers with LocationID of Port , PORT_POS2 : Reprot the Port and each Position with LocationID of Port ,
#				  POSBASE-R : Report for each position of Port Numbers , PORT_POS-R : Reprot the Port and each Position ,
#				  POSBASE2-R : Report for each position of Port Numbers with LocationID of Port , PORT_POS2-R : Reprot the Port and each Position with LocationID of Port , "R" means the Undock Position and Dock Position Report )
#	CARLOCMTX_UNDOCK_LOCID	: Undock Position LocationID for CarrierLocationMatrixList( in default, it is included Port LocationID, ex: if Undock LocID Name is "UNDOCK" and Port1 LocID Name is "LP1", it will be reported with "LP1-UNDOCK" )
#	CARLOCMTX_DOCK_LOCID	: Dock Position LocationID for CarrierLocationMatrixList( in default, it is included Port LocationID, ex: if Dock LocID Name is "DOCK" and Port1 LocID Name is "LP1", it will be reported with "LP1-DOCK" )
#	CARLOCMTX_UNDOCK_LOCID1	: Undock Position LocationID for Port1 CarrierLocationMatrixList
#	CARLOCMTX_DOCK_LOCID1	: Dock Position LocationID for Port1 CarrierLocationMatrixList
#	CARLOCMTX_UNDOCK_LOCID2	: Undock Position LocationID for Port2 CarrierLocationMatrixList
#	CARLOCMTX_DOCK_LOCID2	: Dock Position LocationID for Port2 CarrierLocationMatrixList
#	CARLOCMTX_UNDOCK_LOCID3	: Undock Position LocationID for Port3 CarrierLocationMatrixList
#	CARLOCMTX_DOCK_LOCID3	: Dock Position LocationID for Port3 CarrierLocationMatrixList
#	CARLOCMTX_UNDOCK_LOCID4	: Undock Position LocationID for Port4 CarrierLocationMatrixList
#	CARLOCMTX_DOCK_LOCID4	: Dock Position LocationID for Port4 CarrierLocationMatrixList
#	CARLOCMTX_POS_CARID_TP	: CarrierID Report Type for CarrierLocationMatrixList When a Carrier Present( Format : XXX+YYY, XXX means a CarrierID Data Type When CarrierID absend, YYY means a CarrierID Data Type of Dock/Undock Position When CarrierID present
#				  NULL+NULL, NULL+CARID, UNKNOWN+NULL, UNKNOWN+CARID )
#	MDLNSOFTREV_CHECK_USE	: Determine to check the MDLN and SOFTREV( Compare the Equipment and Host , YES = Compare Check, NO = No Check )
#	MDLNSOFTREV_SEND_USE	: When send S1F2 or S1F14, Determint to send the MDLN and SOFTREV( YES = Send , NO = Not Send(List=0) )
#	ALED_DISABLE_SPEC	: DEFAULT( 0x00 = disable, equipment alarm no happen and no report to host , default ), SEMI( 0x00 = disable, equipment alarm happen but no report to host )
#	ALARM_REPORT_TYPE	: Determine how to report the alarm text when a Alarm happens( EQUIPMENT : Report a Defiend Alarm in Equipment Program, ALID : Report a Defined Alarm in ALID.cfg file ) 
#	ALARM_REPORT_MESSAGE	: When alarm post and clear, Determine the report type( S5F1 : S5F1 SECS Message Report, EVENT : Event Report(S6), BOTH : S5F1 and Event Report )
#	TERMINALMSG_MAX_SIZE	: Max Length of the Single Terminal Message( 50 <= Length <= 250 )
#	TERMINALMSG_REC_MESSAGE	: When User recognize the message box receiving from host, Determine the report type( NONE : No report, S10F1 : Terminal Message, EVENT : Event Report(S6) )
#	TERMINALMSG_TID_MULTI	: When Equip. receive the Terminal Message with a different TID from HOST, Determine to display the multi window( NO : only one window popup, YES : multi window popup ) 
#	S7F65_PPID_UPLOAD_TYPE	: In S7F65, Recipe Parameter Upload Type to Host( PARTIAL( Deafult ), TOTAL )
#	PPIDNAME_TYPE_FORHOST	: Name Character Type of PPID for HOST( ANYTHING : Don't Care, CAPITAL : Large Letter, SMALL : Small Letter )
#	PPID_GROUPNAME_REMOVE	: Determine to remove the group name for the GEM.PPID of DVID( NO : No Remove, YES : Remove )
#	PPIDEDITSTS_REPORT_TYPE	: Determine to value the PPIDEdit Status(PPChangeStatus)( FROM_0 : 0=Create, 1=Update, 2=Delete , FROM1 : 0=None, 1=Create, 2=Update, 3=Delete )
#	CCODE_REPORT_FORMAT	: Format of CCODE to send to host( INT1TYPE, INT2TYPE , INT4TYPE , UINT1TYPE , UINT2TYPE , UINT4TYPE )
#	DENY_USE_FOR_S7F17	: Determine to use a deny(notack) for S7F17(PPID Delete) when PPID don't exist( NO : Not use a deny, YES : Use deny )
#	PPID_SEPCHAR_IN_S7	: Charater to separate the PPID in S7Fx( Default : '|' )
#	S7F23_F25_PP_UPDN_TYPE	: In S7F23/F25, PP Upload/Download Type( ALL_DATA_ONLY : Only Data is used for Lot/Cluster/PM Recipe, PM_NAME_DATA : Only Data is used for Lot/Cluster Recipe, Name and Data is used for PM Recipe )
#	PP_VALUE_NUMBER_CHECK	: Determine to check whether Process Recipe Value is number or not for Int or Float Type( NO : No Check, YES : Check, if Value is not a number, then error )
#	USER_DATAID_USE		: Determine to use a fixed DATAID information specified by user or host( YES : Use, NO : Not Use(default) ) => string data(DATAID format = ascii)
#	USER_DATAID_DEFINITION	: When USER_DATAID_USE = YES to send, DATAID information specified by user
#	S3F17_DATAID_SCENARIO	: In S3F17, Determine to use or not the DATAID( DEFAULT(default) : DATAID use( 0 = ID Verification, 1 = Map Verification, 2 = ID Set), SEMI : DATAID not used )
#	S2F33F35_DATAID_MODE	: Determine to configre the DataID in S2F33/F35( COMMON : DataID don't mean, SEPARATE : Link information is configred as DataID )
#	ALL_RPTID_CEID_DELETE	: Determine to delete all for RPTID and CEID Link Data( S2F33+S2F35 : use the list 0 of each message, S2F33 : use the list 0 of S2F33 )
#	TRACE_DSPER_TYPE	: Determine the DSPER Type in Trace Setup( HHMMSS : hour/Min/Sec and STIME is 14Byte, HHMMSS-16 : hour/Min/Sec and STIME is 16Byte, HHMMSSCC : hour/Min/Sec/mSec => minimum 500 msec(00000050) )
#	TRID_REPORT_FORMAT	: Format of TRID to send to host in S6F1( INT1TYPE, INT2TYPE , INT4TYPE , UINT1TYPE , UINT2TYPE , UINT4TYPE )
#	TRACE_REPGSZ_USE	: Determine to use REPGSZ Parameter in Trace( NO : Group Not Use, ML+SCO+SSD, ML+SCO+SSS, ML+SCS+SSD, ML+SCS+SSS, MV+SCO+SSD, MV+SCO+SSS, MV+SCS+SSD, MV+SCS+SSS )
#				  ML : Multi List Type, MV : Multi VID Type, SCO : Sample Count Host Send Ordering, SCS : Sample Count is Sampled Numbers, SSS : When Stop/Completed, Remain Sample Host Send, SSD : When Stop/Completed, Remain Sample Delete( Host No Send)
#	TRACE_DATA_GATHERING	: Determine the Trace Data Gathering Type( GROUP : GROUP Monitoring, SINGLE : Memory Direct IO Monitoring )
#	COMMDELAYTIME_FORS1F13	: Delay time to send the S1F13 after receiving the notack of S1F14 or after it don't receive the S1F14( 0 <= x <= 100 Sec )
#	CONTROL_AFTER_ESTABLISH	: Determine a Control State Mode After Establish(S1F13)( OFFLINE , LOCAL , REMOTE )
#	ERRORCODE_EXPAND_USE	: YES = expanded spec(default). used, NO = only SEMI(up to 47)
#	EQUIP_MAP_VERIFICATION	: After receive the contentmap through ID ProceedWithCarrier(S3F17), Determine whether equipment automatically run the map verification or not.( YES = Equip Map verification Run(default), NO = not( one more it need the MAP ProceedWithCarrier(S3F17) )
#	PFEVENT_PRCS_CEID_TYPE	: In Preformat Event Report S6F3 or S6F9, When PM Process End Event happens, Definition for CEID Value( ID_TYPE : CEID Value(default), RESULT_TYPE : Process Result Value(0=Normal,1=Abnormal) )
#	FUNCLIST_RCMD_STS_CHK	: Determine to check a status for function or list RCMD( NO : no check, YES : check(default) )
#	IDMAP_VERIFY_IO_CHK	: Determine to check ID or Map Verification in S3F17 PROCEEDWITHCARRIER with ID/MAP Verification IO( NO : no check(default), YES : check )
#	S1F3_LENGTH_0_ACCEPT	: Determine to recognize length 0 of S1F3 for all SVID request( NO : illegal, YES : recognition )
#	BIND_SCENARIO_USE	: Determine to use the Bind Scenario for S3F17( NO : Not Use, YES : Use );
#	PWC_CIDFAIL_RETURN_MODE	: Determine to return value for S3F18 when CarrierID Check is Failed in ProceedWithCarrier(S3F17)( ACK : Normal Return, NACK : Error Return )
#	ECID_READ_TYPE		: Determine to read ECID value( LOCAL : from Memory, REMOTE : from IO )
#	TIME_FORMAT_TYPE	: Determine to configure TimeFormat Option( FIXED : Default( EVENTTIME & TRACETIME), 12BYTE(YYMMDDhhmmss), 16BYTE(YYYYMMDDhhmmsscc) )
#	CARRIER_OBJ_STATE_MODEL	: Carrier Object State Model Type( DEFAULT : Already Model, SEMI : Semi Standard Model )
#	SUBST_OBJ_PROCESS_MODEL	: Substrate Object Process State Model Type for Only SEMI Standard Based( FULL_SEMI : Normal SEMI Scenario, InProcess and NeedPrcs Event Happen between PM to PM, NO_INNEEDPRCS : No Happen with InProcess and NeedPrcs Event between PMs )
#	SUBST_SRCDEST_TIME	: Substrate Source/Destination Data Change Time( SRCDEST_EVENT : when SOURC/DESTINATION Event happen, OCCUPY_EVENT : when Occupy(Destination)/Unoccupy(Source) Event happen )
#	SUBST_LOC_OCCUPY_EVENT	: Subst Location Occupied/Unoccupied Event Mode( MDL_ONLY : Only Module Subst Occupied/Unoccupied Event Happen, MDL_ROBOT : Module and Robot Subst Occupied/Unoccupied Event Happen(FM Side Animation), MDL_ROBOT_FM : Module and Robot Subst Occupied/Unoccupied Event Happen(FM Side Picking/Placing), 
#				  INTEGRATION_AB : OCCUPY/AT_WORK/UNOCCUPY Integration Event Report Type when Robot is piacked or placed physically, "_AB" mean Arm A->B report when Double Wafer in FM side,
#				  INTEGRATION_BA : OCCUPY/AT_WORK/UNOCCUPY Integration Event Report Type when Robot is piacked or placed physically, "_BA" mean Arm B->A report when Double Wafer in FM side,
#				  INTEGRATION_AB-R : UNOCCUPY/AT_WORK/OCCUPY Integration Event Report Type when Robot is piacked or placed physically, "_AB" mean Arm A->B report when Double Wafer in FM side(SEMI),
#				  INTEGRATION_BA-R : UNOCCUPY/AT_WORK/OCCUPY Integration Event Report Type when Robot is piacked or placed physically, "_BA" mean Arm B->A report when Double Wafer in FM side(SEMI) )
#	EQ_VERIFY_OF_CONTENTMAP	: When S3F17 don't have SlotMap Attribute and have ContentMap Attribute, Determine to use the ContentMap Attribute to verify Equipment Map Data( NO : Not Use, YES : Use )
#	CANCELCARRIER_LP_CHECK	: When Host send a CancelCarrier and CancelCarrierAtPort, Determine to check the status of LoadPort( NO : No Check(DEFAULT), YES : Check( RTU/RTL/RUNNING ) )
#	E99_CIDRW_SEMI_VERSION	: E99 CIDRW SECS Scenario SEMI Version( PREVIOUS : Previous Version of 1104, SEMI1104 : SEMI 1104 Version )
#	EVENT_FOR_CARRECREATE	: Event Report Type for Unload and Load after CarrierRecreate( PARTIAL : Only RTU->TB, ID_Not_Read, Clamp, FULL : Same Event Report for Normal Unload and Load )
#	WAFER_HANDLING_EVENT	: Determine to use a Picking/Placing/Picked/Placed/Picked2/Placed2 Event of Robot Wafer Handling( ALL_INTERNAL : Use the Internal sent from scheduler, FEM_EXTERNAL : TM is Used with Interanl but FM is Used with User )
#	SEP_FOR_MULTIWAFEREVENT	: Determine to separate a Event with Multi Wafer( NO : No Separation, YES : Separation )
#	SOSM_SCT4_REPORT_FOR_LP	: In the case of SUBST_LOC_OCCUPY_EVENT option is INTEGRATION, Determine to report the SOSM SCT4(AtWork->AtWork) for LP and SCT2(Source->Work) Event Report Position( INCLUDED : SCT4 of LP is reported and SCT2 is reported at LP, REMOVED : SCT4 of LP is not reported and SCT2 is reported after Picked from EFEM Robot )
#	INIT_SUBST_EVENT_REPORT	: Determine the Report Position for NoState -> AtSource/NeedProcess/Occupied Event( AFTER_MAPPING : Report after Maaping Completed Event, AFTER_MVO : Report after Map Verification OK Event )
#	UNKNOWN_VID_REPORT_TYPE	: Determine the report data type of Unknown VID in S1F3, S1F11, S2F13, S2F29( NULL : ASCII Blank, LIST_0 : List 0 Report ) 
#	S1F3_DATA_GATHERING	: Determine the S1F3 Data Gathering Type( GROUP : GROUP Monitoring, SINGLE : Memory Direct IO Monitoring )
#	MSGCHECK_BEFORE_SEND	: Determine to check a error character in message before send to Host( NO : No Check , YES : Check )
#	MCC_DATA_GATHERING	: Determine to gather the Internal MCC Data with Default User MCC Data( NO : No Gathering, MAP, MAP+TR, MAP+PRCS, MAP+RCP, MAP+STEP, MAP+TR+PRCS, MAP+TR+RCP, MAP+TR+STEP, MAP+PRCS+RCP, MAP+PRCS+STEP, MAP+RCP+STEP, MAP+TR+PRCS+RCP, MAP+TR+PRCS+STEP, MAP+TR+RCP+STEP, MAP+PRCS+RCP+STEP, MAP+TR+PRCS+RCP+STEP )
#				  MAP : Mapping Start/End Gathering, TR : Robot Transfer Pick/Place Gathering, PRCS : PM Process Start/End Gathering, RCP : PM Multi Recipe Start/End Gathering, STEP : PM Step Start/End Gathering
#	CLUSTER_LOOP_SUPPORT	: Determine to support that wafer run cycle with Cluster Recipe(Special Recipe)( NO : Not Support, YES : Support )
#	STS_FOR_MULTI_CARRIER	: Determine to support the Substrate Data for Multiple Carrier( Source/Destination Carrier of CJ MtrlOutSpec is different )( NO : Not Support, Only Single Carrier , YES : Support )
#---------------------------------------------------------------------------------
DEVICE_ID		1
RECONNECT_INIT		YES
RETURN_ONLINE_STATUS	NO
RETURN_RECONNECT_TIME	30
RETURN_PREMODE_DISCONBYEQ NO
LINKTEST_ENABLE		ENABLE
LINKTEST_SEND_MODE	I+S+A
IDLE_LINKTEST_TIME	10
S6F2RESP_ENABLE		DISABLE
S6F12RESP_ENABLE	ENABLE
S6F14RESP_ENABLE	ENABLE
ATTEMPT_ESTABLISH	YES
ESTABLISH_CHECK		YES
RSPMSG_RETRY_COUNT	0

EVENTDEF_MODE		SAVE
FORMAT_EVENT_TYPE	S6F3
NOTIFY_EVENT_TYPE	S16F7
NORMAL_EVENT_TYPE	S6F11

REMOTE_INIT_SET		PREVIOUS
ONLINE_EVENT_TYPE	ONLINE
OFFL_MESSAGE_LIMIT	REJECT
REPORT_ALREADY_OFFLINE	NOTACK
RES_FOR_S1F1_IN_OFFLINE	ABORT

DMYWFR_PMEVENT_MODE	NO
CARCOMPLETE_EVENT_MODE	NO
LOTCLT_PPID_EDIT_EVENT	YES
PPID_EDIT_DETAIL_EVENT	YES
PPID_EDIT_REPORT_MODE	ALLGRP+USEGN
PORT_EVENT_IN_300mm	COMMON
PROCES_EVENT_IN_300mm	SEPARATE
PRCS_STEP_EVT_IN_300mm	CHANGED
PRCS_ABNML_EVT_IN_300mm	PROCESSED
SUBSTNEEDPRCS_EVENT_POS	PORT+PMEND
NOBIND_BYPASSON_EVENT	READFAIL_EVENT
NOBIND_IDREADFAIL_EVENT	READFAIL_EVENT
EVERY_SUBST_EVT_OF_PORT	WAFER
EVERY_SUBST_OCCUPY_EVT	PER_WAFER
EVERY_SUBST_NEEDPRS_EVT	PER_WAFER
CAR_NOTASSOCIATED_EVENT	ALWAYS
DATA_COLLECT_EVENT_RPT	NO	
HOSTGUI_PPID_EDIT_EVENT COMMON
HOSTGUI_EC_CHANGE_EVENT	COMMON

SPOOL_MODE		RECV
MAX_SPOOL_MESSAGE	1000
SPMSG_RESP_ENABLE	ENABLE
REJECT_MSG_SPOOL	DISABLE

TERMINAL_MSG_SEP	NO
MSGBOX_BIGFONT_USE	NO
MESSAGE_BOX_STYLE	UPDATE
MSGBOX_AUTODEL_TIME	10
VERIFYMSG_BOX_STYLE	CONFIRM
VERIFYMB_AUTODEL_TIME	10

MID_VERIFY_TYPE		MID
MID_READ_ACTION_TYPE	THREAD
MID_WRITE_ACTION_TYPE	THREAD

GEM_SERVER_ON_IO	e:GEM.CONTROL
GEM_EQUIP_TYPE		300mm
CLUSTER_TYPE		CTC

HISTORY_CHAMBER_ORDER	MODULE_BASE
HISTORY_LOG_TYPE	NAME_BASED
HISTORY_WFR_SYNCH_CHECK	YES+PM

PRJOB_AUTO_DELETE	YES
PJCOMPLT_EVENT_DETAIL	YES
CJCOMPLT_EVENT_DETAIL	YES
PJCOMPLT_EVT_INABORT	YES
CJCOMPLT_EVT_INABORT	YES
JOB_USER_LEVEL_INTLK	5
S14F9_MTRLOUTSPEC_TYPE	SEPARATE
JOB_STARTMODE_TYPE	SEMI
CJ_COMMAND_TYPE		TYPE1
S14F11_OBJSPEC_TYPE	ATTRID
PJ_RECIPEMETHOD_TYPE	RCP1_TUN2
QUEUEDJOB_CMD_REJECT	NO
DESELECTTOQUEUE_EVENT	NO
PJPRCS_EVENT_IN_PJSTOP	YES
MTRL_SLOT_TYPE_IN_PJ	SLOTID
S14F9_CJ_RESPONSE_TYPE	SEMI	
CJ_STOPABORT_EVENT_IN_Q	COMPLETED	
CJ_DEL_EVENT_TYPE_IN_Q	DELETE
JOB_DELETED_IN_RTU	YES
PJ_RECID_FORMAT		NORMAL
PJ_TUNING_FORMAT	NORMAL
PJ_TUNING_TIME		QUEUED
PJ_SETUP_STS_SCENARIO	S_B_R+P_A_R
PJ_PRCSCOM_STS_SCENARIO	NORMAL
PJ_RCPMODE_FOR_S16F23	AUTO
PJ_MF_CHECK_TYPE	CARRIER
PJ_DEL_EVENT_TYPE_IN_Q	SEND	

SCH_INTERFACE_FUNC	""
JOB_INTERFACE_FUNC	""

STEPDATA_ANALYSIS_USE	NO
STEPDATA_ANALYSIS_FNC	""
PRCSDATA_ANALYSIS_USE	NO
PRCSDATA_ANALYSIS_FNC	""
LOTDATA_ANALYSIS_USE	NO
LOTDATA_ANALYSIS_FNC	""
PJDATA_ANALYSIS_USE	NO
PJDATA_ANALYSIS_FNC	""
TKINOUT_ANALYSIS_USE	NO
TKINOUT_ANALYSIS_FNC	""

HOSTCMD_INTERFACE_FUNC	""
EVENT_INTERFACE_FUNC	""
PPID_INTERFACE_FUNC	""

PORT_LOCATIONID_TYPE	LOCATIONID

LOCATIONID_NAME_CM1	"CM1"
LOCATIONID_NAME_CM2	"CM2"
LOCATIONID_NAME_CM3	"CM3"
LOCATIONID_NAME_CM4	"CM4"
LOCATIONID_NAME_FM	"FM"
LOCATIONID_NAME_FAL	"FAL"
LOCATIONID_NAME_FIC	"FIC"
LOCATIONID_NAME_BM1	"BM1"
LOCATIONID_NAME_BM2	"BM2"
LOCATIONID_NAME_BM3	"BM3"
LOCATIONID_NAME_BM4	"BM4"
LOCATIONID_NAME_TM	"TM"
LOCATIONID_NAME_TM2	"TM2"
LOCATIONID_NAME_AL	"AL"
LOCATIONID_NAME_IC	"IC"
LOCATIONID_NAME_PM1	"PM1"
LOCATIONID_NAME_PM2	"PM2"
LOCATIONID_NAME_PM3	"PM3"
LOCATIONID_NAME_PM4	"PM4"
LOCATIONID_NAME_PM5	"PM5"
LOCATIONID_NAME_PM6	"PM6"
LOCATIONID_NAME_PM7	"PM7"
LOCATIONID_NAME_PM8	"PM8"
LOCATIONID_NAME_PM9	"PM9"
LOCATIONID_NAME_PM10	"PM10"
LOCATIONID_NAME_PM11	"PM11"
LOCATIONID_NAME_PM12	"PM12"

MODELNUMBER		""
SOFTVERSION		""

EXT_TERMINAL_BOX_USE	NO
EXT_TERMINAL_BOX_FUNC	""

CONTENTMAP_DATA_TYPE	SEPARATE
LOCATIONID_DATA_TYPE	ASCII
SLOTMAP_DATA_TYPE	LIST_EXTEND
USAGE_DATA_TYPE		SEMI
TUNING_DATA_SEP_CHAR	","
LOCID_DATA_SEP_CHAR	"."
S14F1_MF_REPORT_TYPE	BINARY
OBJ_REPORT_IN_OSS_FAIL	OBJID
SUBST_SOURCE_DEST_DATA	CARRIERID+SLOT
DEST_DATA_WITH_SAME_SRC	NULL
SUBST_ATTRIBUTE_EXTEND	YES
SUBST_LOCID_DETAIL	NO
SUBSTRATE_OBJTYPE	COMMON
CAR_OBJECT_FOR_LIST_0	PORTBASE
SUBSTID_FOR_UNOCCUPIED	BLANK
WAFERIDLIST_FOR_EVENT	ONLY_WAFER
PRCSSTATE_FOR_PM_PRCSED	PROCESSED
USAGE_DATA_VALUE_TYPE	PRODUCT_2
SUBST_HISTORY_REPORT	ALL
CARLOCMTX_REPORT_TYPE	POSBASE2-R
CARLOCMTX_UNDOCK_LOCID	"UNDOCK"
CARLOCMTX_DOCK_LOCID	"DOCK"
CARLOCMTX_UNDOCK_LOCID1	"LOADPORT1"
CARLOCMTX_UNDOCK_LOCID2	"LOADPORT2"
CARLOCMTX_UNDOCK_LOCID3	"LOADPORT3"
CARLOCMTX_UNDOCK_LOCID4	"LOADPORT4"
CARLOCMTX_DOCK_LOCID1	"FIMSPORT1"
CARLOCMTX_DOCK_LOCID2	"FIMSPORT2"
CARLOCMTX_DOCK_LOCID3	"FIMSPORT3"
CARLOCMTX_DOCK_LOCID4	"FIMSPORT4"
CARLOCMTX_POS_CARID_TP	UNKNOWN+NULL

MDLNSOFTREV_CHECK_USE	NO
MDLNSOFTREV_SEND_USE	YES

ALED_DISABLE_SPEC	SEMI
ALARM_REPORT_TYPE	EQUIPMENT
ALARM_REPORT_MESSAGE	S5F1

TERMINALMSG_MAX_SIZE	250
TERMINALMSG_REC_MESSAGE	NONE	
TERMINALMSG_TID_MULTI	NO

S7F65_PPID_UPLOAD_TYPE	PARTIAL
PPIDNAME_TYPE_FORHOST	ANYTHING
PPID_GROUPNAME_REMOVE	NO
PPIDEDITSTS_REPORT_TYPE	FROM_1
CCODE_REPORT_FORMAT	UINT2TYPE
DENY_USE_FOR_S7F17	YES
PPID_SEPCHAR_IN_S7	"|"
S7F23_F25_PP_UPDN_TYPE	ALL_DATA_ONLY
PP_VALUE_NUMBER_CHECK	YES

USER_DATAID_USE		NO
USER_DATAID_DEFINITION	""
S3F17_DATAID_SCENARIO	SEMI
S2F33F35_DATAID_MODE	COMMON
ALL_RPTID_CEID_DELETE	S2F33

TRACE_DSPER_TYPE	HHMMSS
TRID_REPORT_FORMAT	UINT4TYPE
TRACE_REPGSZ_USE	MV+SCS+SSD
TRACE_DATA_GATHERING	GROUP

COMMDELAYTIME_FORS1F13	0
CONTROL_AFTER_ESTABLISH	OFFLINE

ERRORCODE_EXPAND_USE	NO
EQUIP_MAP_VERIFICATION	YES
PFEVENT_PRCS_CEID_TYPE	ID_TYPE
FUNCLIST_RCMD_STS_CHK	YES
IDMAP_VERIFY_IO_CHK	NO
S1F3_LENGTH_0_ACCEPT	NO
BIND_SCENARIO_USE	YES
PWC_CIDFAIL_RETURN_MODE	ACK
ECID_READ_TYPE		LOCAL
TIME_FORMAT_TYPE	16BYTE
CARRIER_OBJ_STATE_MODEL	SEMI
SUBST_OBJ_PROCESS_MODEL	FULL_SEMI
SUBST_SRCDEST_TIME	SRCDEST_EVENT
SUBST_LOC_OCCUPY_EVENT	INTEGRATION_AB-R
EQ_VERIFY_OF_CONTENTMAP	NO
CANCELCARRIER_LP_CHECK	YES
E99_CIDRW_SEMI_VERSION	SEMI1104
EVENT_FOR_CARRECREATE	PARTAIL
WAFER_HANDLING_EVENT	ALL_INTERNAL
SEP_FOR_MULTIWAFEREVENT	YES
SOSM_SCT4_REPORT_FOR_LP	REMOVED
INIT_SUBST_EVENT_REPORT	AFTER_MVO
UNKNOWN_VID_REPORT_TYPE NULL
S1F3_DATA_GATHERING	GROUP
MSGCHECK_BEFORE_SEND	YES
MCC_DATA_GATHERING	NO
CLUSTER_LOOP_SUPPORT	NO
STS_FOR_MULTI_CARRIER	YES

#---------------------------------------------------------------------------------
#	GEM TIMER PARAMETER
#
#   	T1		: Specifies Time in RS232 ( 1 - 10 )
#   	T2		: Specifies Time in RS232 ( 1 - 25 )
#   	T3		: Specifies Reply Timeout in HSMS ( 1 - 120 )
#   	T4		: Specifies Time in RS232 ( 1 - 120 )
#   	T5		: Specifies elased Time that Try TCPIP Connection in HSMS( = when Active type ) ( 1 - 240 )
#   	T6		: Specifies Control Message Transaction Timeout( Reply Timeout Control Message ) in HSMS ( 1 - 240 )
#   	T7		: Specifies Timeout from TCPIP Connection to Select.req in HSMS ( = when Passive Type) ( 1 - 240 )
#   	T8		: Specifies Timeout between Message Block in HSMS ( 1 - 120 )
#---------------------------------------------------------------------------------
T1			0.5
T2			10
T3			45
T4			45
T5			5
T6			5
T7			10
T8			5

#---------------------------------------------------------------------------------
#	RECIPE CONFIG/PATH
#
#   	RECIPE_ROOT_PATH	: Recipe Directory Root
#   	RECIPE_GROUP_USE	: Grouping Use( NO : No Use(Default) , YES : Use )
#	FIXED_RCPPATH_USE	: Determine to use a Fixed Recipe Path( YES : Use, NO : NotUse )
#	FIXED_RCPPATH_NAME	: If use a Fixed Recipe Path, Define the Recipe Path Name
#	LOT_RECIPE_SAVE_TYPE	: Empty Slot Define( FILL - Equal Up Recipe , SKIP - Empty Skip )
#	CLUSTER_RECIPE_FORMAT	: Cluster Recipe Format( NORMAL , EXTEND=Multi Recipe+User Data , EXTEND2 : User Data Use in Normal Format , EXTEND3=Multi Recipe+User Data+Loop User Data )
#	CLUSTER_RECIPE_TYPE	: Recipe Mode ( PNP-Prepare,Process(Normal),Post Process , NP-Normal,Post , 
#				  PN-Prepare,Normal , N-Normal(only Process Recipe )
#	RECIPE_SAVE_MODE	: Lot/Cluster/Process Recipe Save Mode( SEPARATE - each Independent , 
#				  DEPEND - Process Recipe Dependent ), now only SEPARATE
#	CLUSTER_ITEM_COUNT	: Cluster Flow ID Count( Max <= 50 )
#	CLUSTER_SAVE_DEPTH	: When cluster recipe is saved, determine order depth count( Max <= 64 )
#	RECIPE_SCENARIO		: If Adaptor , ( USE : Adaptor , NOTUSE : Not Adaptor , SEMI )
#				  SEMI : When PPID is downloaded from Equipment(S7F25) or Host(S7F23), Send the S7F27 without regard to error
#	MAX_CASSETTE_SLOT	: Max Cassette Slot Define( Max <= 30 )
#	PRJOB_CREATE_RECIPE_TYPE: When PRJOB is created with recipe name, determine whether the recipe is cluster or lot( CLUSTER, LOT )
#	LOT_RECIPE_DUMMY_COUNT	: Dummy count in lot recipe( 0 <= x <= 30-MAX_CASSETTE_SLOT ), but now supported only 1 dummy
#	PPID_FULLDOWN_OVERWRITE	: When PPID for Full Body is downed from host(S7F23), if PPID already exist, Determine to overwrite the PPID( NO : don't overwrite(reject), YES : overwrite )
#	PPID_SAVE_USER_TIME_USE	: When PPID is saved from Host or GUI, Determine to use the Recipe Save User and Time Information( NO : Not Use, YES : Use, EXTEND )
#	PPID_EDITOR_SW_VERSION	: When PPID_SAVE_USER_TIME_USE is EXTEND, Editor Software Version Name
#   	LOT_RECIPE_PATH		: Lot Recipe Directory
#   	CLUSTER_RECIPE_PATH	: Cluster Recipe Directory
#   	PMx_RECIPE_PATH		: PM x Recipe Directory( Max 20 )
#   	LOT_RECIPE_USE		: Lot Recipe Use( NO : No Use(Default) , YES : Use )
#   	CLUSTER_RECIPE_USE	: Cluster Recipe Use( NO : No Use(Default) , YES : Use )
#	PMx_RECIPE_USE		: PM x Recipe Use( NO : No Use(Default) , YES : Use )
#	All String Max Length 255
#	When Communites with HOST, 
#	LOT = LOT , CLUSTER = CLT , PM1 = PM1 ... PM20 = PM20
#---------------------------------------------------------------------------------
RECIPE_ROOT_PATH	RECIPE

RECIPE_GROUP_USE	NO
FIXED_GROUP_USE		NO
FIXED_GROUP_NAME	""

LOT_RECIPE_SAVE_TYPE	FILL
CLUSTER_RECIPE_FORMAT	NORMAL
CLUSTER_RECIPE_TYPE	N
RECIPE_SAVE_MODE	SEPARATE	
CLUSTER_ITEM_COUNT	4	
CLUSTER_SAVE_DEPTH	12

RECIPE_SCENARIO		SEMI
MAX_CASSETTE_SLOT	25

PRJOB_CREATE_RECIPE_TYPE LOT
LOT_RECIPE_DUMMY_COUNT	0

PPID_FULLDOWN_OVERWRITE	YES
PPID_SAVE_USER_TIME_USE	NO
PPID_EDITOR_SW_VERSION	"VER1.0"

LOT_RECIPE_PATH		LOT
CLUSTER_RECIPE_PATH	CLUSTER
PM1_RECIPE_PATH		PROCESS\PM1
PM2_RECIPE_PATH		PROCESS\PM2
PM3_RECIPE_PATH		PROCESS\PM3
PM4_RECIPE_PATH		PROCESS\PM4
PM5_RECIPE_PATH		PROCESS\PM5
PM6_RECIPE_PATH		PROCESS\PM6
PM7_RECIPE_PATH		PROCESS\PM7
PM8_RECIPE_PATH		PROCESS\PM8
PM9_RECIPE_PATH		PROCESS\PM9
PM10_RECIPE_PATH	PROCESS\PM10
PM11_RECIPE_PATH	PROCESS\PM11
PM12_RECIPE_PATH	PROCESS\PM12

LOT_RECIPE_USE		YES
CLUSTER_RECIPE_USE	YES
PM1_RECIPE_USE		YES
PM2_RECIPE_USE		YES
PM3_RECIPE_USE		YES
PM4_RECIPE_USE		YES
PM5_RECIPE_USE		NO
PM6_RECIPE_USE		NO
PM7_RECIPE_USE		NO
PM8_RECIPE_USE		NO
PM9_RECIPE_USE		NO
PM10_RECIPE_USE		NO
PM11_RECIPE_USE		NO
PM12_RECIPE_USE		NO

#---------------------------------------------------------------------------------
#	HARDWARE CONFIG PART
#
#	PM_WFRSRC_SAME		: Determine to use same wafer source in a PM, YES(=Same), NO(=Not Same)
#	xM_VIEW_COUNT		: When Module Information is saved or Module is used in EasyGem, determine the module count
#				: CM <= 4, FM <= 1, BM <= 10, TM <= 5, PM <= 64  
#	x_MODULE_USE		: Determine Module Use, x = Module, YES(=Use), NO(=Not Use)
#	CASSETTE_NUMBERS_CMx	: Cassette Slot Numbers( 1 <= x <= 30 )
#	FAL_LAYER_NUMBERS	: FM Aligner Layer Numbers( 1 <= x <= 1 )
#	FIC_LAYER_NUMBERS	: FM Cooler Layer Numbers( 1 <= x <= 30 )
#	PROCESS_NUMBERS_BMx	: Buffer Module Numbers for 1 Module, 1 <= y <= 30, x = Module Number
#	AL_LAYER_NUMBERS	: TM Aligner Layer Numbers( 1 <= x <= 1 )
#	IC_LAYER_NUMBERS	: TM Cooler Layer Numbers( 1 <= x <= 1 )
#	PROCESS_NUMBERS_PMx	: Process Numbers for 1 Chamber, 1 <= y <= 30, x = Chamber Number
#	x_FINGER_USE		: Robot Finger Use, x( TA = TM Robot Arm A, TB = TM Robot Arm B,... TB5 = TM5 Robot Arm B
# 				  FA = FM Robot Arm A , FB = FM Robot Arm B), YES(=Use), NO(=Not Use)
#	x_FINGER_NUMBERS	: x = FA,FB,TA,TB,TA2,TB2...TA5,TB5 Arm, TM/FM Robot Arm Numbers( 1 <= y <= 30 )
#---------------------------------------------------------------------------------
PM_WFRSRC_SAME		YES

CM_VIEW_COUNT		4
FM_VIEW_COUNT		1
BM_VIEW_COUNT		4
TM_VIEW_COUNT		1
PM_VIEW_COUNT		12

CM1_MODULE_USE		YES
CM2_MODULE_USE		YES
CM3_MODULE_USE		NO
CM4_MODULE_USE		NO
FM_MODULE_USE		NO
FAL_MODULE_USE		NO
FIC_MODULE_USE		NO
BM1_MODULE_USE		NO
BM2_MODULE_USE		NO
BM3_MODULE_USE		NO
BM4_MODULE_USE		NO
TM_MODULE_USE		YES
AL_MODULE_USE		YES
IC_MODULE_USE		NO
PM1_MODULE_USE		YES
PM2_MODULE_USE		YES
PM3_MODULE_USE		YES
PM4_MODULE_USE		NO
PM5_MODULE_USE		NO
PM6_MODULE_USE		NO
PM7_MODULE_USE		NO
PM8_MODULE_USE		NO
PM9_MODULE_USE		NO
PM10_MODULE_USE		NO
PM11_MODULE_USE		NO
PM12_MODULE_USE		NO

CASSETTE_NUMBERS_CM1	25
CASSETTE_NUMBERS_CM2	25
CASSETTE_NUMBERS_CM3	25
CASSETTE_NUMBERS_CM4	25
FAL_LAYER_NUMBERS	1
FIC_LAYER_NUMBERS	1
PROCESS_NUMBERS_BM1	1
PROCESS_NUMBERS_BM2	1
PROCESS_NUMBERS_BM3	1
PROCESS_NUMBERS_BM4	1
AL_LAYER_NUMBERS	1
IC_LAYER_NUMBERS	1
PROCESS_NUMBERS_PM1	1
PROCESS_NUMBERS_PM2	1
PROCESS_NUMBERS_PM3	1
PROCESS_NUMBERS_PM4	1
PROCESS_NUMBERS_PM5	1
PROCESS_NUMBERS_PM6	1
PROCESS_NUMBERS_PM7	1
PROCESS_NUMBERS_PM8	1
PROCESS_NUMBERS_PM9	1
PROCESS_NUMBERS_PM10	1
PROCESS_NUMBERS_PM11	1
PROCESS_NUMBERS_PM12	1

FA_FINGER_USE		NO
FB_FINGER_USE		NO
TA_FINGER_USE		YES
TB_FINGER_USE		YES
TA2_FINGER_USE		NO
TB2_FINGER_USE		NO

FA_FINGER_NUMBERS	1
FB_FINGER_NUMBERS	1
TA_FINGER_NUMBERS	1
TB_FINGER_NUMBERS	1
TA2_FINGER_NUMBERS	1
TB2_FINGER_NUMBERS	1

